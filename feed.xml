<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SUNG.LOG</title>
  
  <subtitle>불라불라불라</subtitle>
  <link href="/feed.xml" rel="self"/>
  
  <link href="https://ddok2.github.io/"/>
  <updated>2019-02-08T08:33:38.550Z</updated>
  <id>https://ddok2.github.io/</id>
  
  <author>
    <name>SUNG :D</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker 에서 MongoDB 이용하기</title>
    <link href="https://ddok2.github.io/2018/03/08/docker-mongodb/"/>
    <id>https://ddok2.github.io/2018/03/08/docker-mongodb/</id>
    <published>2018-03-08T05:59:24.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mongo-검색"><a href="#Mongo-검색" class="headerlink" title="Mongo 검색"></a>Mongo 검색</h3><p>Command 이용해서 검색하거나 </p><p><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a> 에서 <code>mongo</code> 를 검색합니다.</p><p>command 검색: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker search mongo</span><br></pre></td></tr></table></figure><p><img src="/images/dev/docker.log/docker-mongodb.png" alt=""></p><h3 id="이미지-받기-및-실행"><a href="#이미지-받기-및-실행" class="headerlink" title="이미지 받기 및 실행"></a>이미지 받기 및 실행</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull mongo</span><br></pre></td></tr></table></figure><p>위 명령어 없이 <code>run</code> 명령어 사용하면 자동으로 다운받고 실행을 합니다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --name mongo -p 27017:27017 -d mongo</span><br></pre></td></tr></table></figure><p>위 명령어를 사용하면 <code>mongod</code>가 기동이 됩니다.</p><h3 id="Docker-Container-접속"><a href="#Docker-Container-접속" class="headerlink" title="Docker Container 접속"></a>Docker Container 접속</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -it mongo /bin/bash</span><br></pre></td></tr></table></figure><p>위 명령어 실행하면 컨테이너 안으로 들어가서 해당 명령어를 실행합니다.</p><p>만일 <code>run</code> 하면서 바로 접속하고 싶으면 다음과 같이 해도 됩니다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it --name mongo -p 27017:27017 -d mongo /bin/bash</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Mongo-검색&quot;&gt;&lt;a href=&quot;#Mongo-검색&quot; class=&quot;headerlink&quot; title=&quot;Mongo 검색&quot;&gt;&lt;/a&gt;Mongo 검색&lt;/h3&gt;&lt;p&gt;Command 이용해서 검색하거나 &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hu
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="docker.log" scheme="https://ddok2.github.io/categories/dev/docker-log/"/>
    
    
      <category term="docker" scheme="https://ddok2.github.io/tags/docker/"/>
    
      <category term="mongodb" scheme="https://ddok2.github.io/tags/mongodb/"/>
    
  </entry>
  
  <entry>
    <title>macOS에 Azure CLI 2.0 설치하기</title>
    <link href="https://ddok2.github.io/2018/02/20/install-azure-cli-mac-os/"/>
    <id>https://ddok2.github.io/2018/02/20/install-azure-cli-mac-os/</id>
    <published>2018-02-20T01:16:43.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<p>맥을 이용하는 유저는 Azure CLI를 <a href="https://brew.sh/" target="_blank" rel="noopener">Homebrew</a> 통해서 설치할수 있습니다.</p><h2 id="1-설치하기"><a href="#1-설치하기" class="headerlink" title="1. 설치하기"></a>1. 설치하기</h2><p><code>Homebrew</code> 통해서 설치하는 것이 가장 쉽습니다. <code>Homebrew</code> 통해 업데이트와 삭제도 쉽게 할수 있으니 <a href="https://docs.brew.sh/Installation.html" target="_blank" rel="noopener"><code>Homebrew</code>가 없으면 설치</a>하길 바랍니다.</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew install azure-cli</span><br></pre></td></tr></table></figure><p>설치가 되면 <code>az</code> 명령을 이용하여 Azure CLI를 이용할수 있습니다.</p><h3 id="1-1-설치시-발생되는-문제"><a href="#1-1-설치시-발생되는-문제" class="headerlink" title="1.1 설치시 발생되는 문제"></a>1.1 설치시 발생되는 문제</h3><h4 id="Python-패키지를-찾을-수-없음"><a href="#Python-패키지를-찾을-수-없음" class="headerlink" title="Python 패키지를 찾을 수 없음"></a>Python 패키지를 찾을 수 없음</h4><p>맥에 설치된 <code>Python</code>이 버전이 일치하지 않을 경우나 설치하는 과정에서 다른 문제가 발생할 수 있습니다.<br>그래서 <code>Python</code> 버전을 찾게 다음과 같이 연결하면 됩니다.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew link --overwrite python3</span><br></pre></td></tr></table></figure></p><h4 id="Azure-CLI-1-x가-설치됨"><a href="#Azure-CLI-1-x가-설치됨" class="headerlink" title="Azure CLI 1.x가 설치됨"></a><code>Azure CLI 1.x</code>가 설치됨</h4><p>낮은 버전이 설치된 경우 <code>Homebrew</code> 업데이트 안해서 발생하는 문제입니다. <code>Homebrew</code>를 업데이트한 후 <code>azure-cli</code>를 업그레이드하면 됩니다.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade azure-cli</span><br></pre></td></tr></table></figure></p><h2 id="2-업데이트"><a href="#2-업데이트" class="headerlink" title="2. 업데이트"></a>2. 업데이트</h2><p><code>azure-cli</code>는 약 2주마다 새 릴리즈를 한다고 합니다. 주기적인 업데이트를 받을 수 있습니다.<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew update &amp;&amp; brew upgrade azure-cli</span><br></pre></td></tr></table></figure></p><h2 id="3-삭제"><a href="#3-삭제" class="headerlink" title="3. 삭제"></a>3. 삭제</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew uninstall azure-cli</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;맥을 이용하는 유저는 Azure CLI를 &lt;a href=&quot;https://brew.sh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Homebrew&lt;/a&gt; 통해서 설치할수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;1-설치하기&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="azure.log" scheme="https://ddok2.github.io/categories/dev/azure-log/"/>
    
    
      <category term="azure" scheme="https://ddok2.github.io/tags/azure/"/>
    
  </entry>
  
  <entry>
    <title>Node.js HTTPS 서버 구현</title>
    <link href="https://ddok2.github.io/2018/02/19/nodejs-https/"/>
    <id>https://ddok2.github.io/2018/02/19/nodejs-https/</id>
    <published>2018-02-19T01:19:51.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-SSL-인증서-Letsencrypt"><a href="#1-SSL-인증서-Letsencrypt" class="headerlink" title="1. SSL 인증서, Letsencrypt"></a>1. SSL 인증서, Letsencrypt</h2><p>SSL 인증서는 보통 유료로 구매를 해야합니다. 그러나 무료 인증서를 주는 곳이 몇몇 있습니다.</p><ol><li><a href="https://letsencrypt.org/" target="_blank" rel="noopener">Let’s Encrypt</a> : 유료기간이 90일.</li><li><a href="https://www.gogetssl.com/domain-validation/comodo-free-ssl/" target="_blank" rel="noopener">Comodo Free SSL</a> : 코모도에서 출시한 무료 인증서.</li><li><a href="https://www.cloudflare.com/ssl/" target="_blank" rel="noopener">CloudFlare One-Click SSL</a> : CloudFlare CDN과 함께 사용 가능함.</li><li><a href="https://aws.amazon.com/ko/certificate-manager/" target="_blank" rel="noopener">AWS Certificate Manager</a> 유효기간 자동 갱신.</li></ol><p>그외 더 있지만 여기서는 Let’s Encrypt를 이용해서 인증서를 받았습니다.</p><p>윈도우 서버에서 테스트를 할 예정이라 <a href="https://github.com/Lone-Coder/win-acme" target="_blank" rel="noopener">letsencrypt-win-simple</a> 이용하여 인증서를 받았습니다.<br><a href="https://github.com/Lone-Coder/win-acme" target="_blank" rel="noopener">letsencrypt-win-simple</a> 의 자세한 내용은 <a href="https://github.com/Lone-Coder/win-acme/wiki" target="_blank" rel="noopener">wiki</a> 를 참고하세요.</p><p><img src="/images/dev/node.log/nodejs-https-windows-server.png" alt=""></p><h2 id="2-HTTPS-서버-구현"><a href="#2-HTTPS-서버-구현" class="headerlink" title="2. HTTPS 서버 구현"></a>2. HTTPS 서버 구현</h2><p><a href="https://nodejs.org/api/https.html#https_https_createserver_options_requestlistener" target="_blank" rel="noopener">Node.js HTTPS Documentation</a>를 참고하세요.</p><p>예제는 아래와 같습니다.</p><p>방법 1:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// curl -k https://localhost:8000/</span></span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'test/fixtures/keys/agent2-key.pem'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'test/fixtures/keys/agent2-cert.pem'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">https.createServer(options, (req, res) =&gt; &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></p><p>방법 2:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  pfx: fs.readFileSync(<span class="string">'test/fixtures/test_cert.pfx'</span>),</span><br><span class="line">  passphrase: <span class="string">'sample'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">https.createServer(options, (req, res) =&gt; &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  res.end(<span class="string">'hello world\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure></p><p>만일 <a href="http://expressjs.com/" target="_blank" rel="noopener">Express</a>를 이용하여 구현한다면 다음과 같이 구현하면 됩니다.</p><p>with Express:<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'test/fixtures/keys/agent2-key.pem'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'test/fixtures/keys/agent2-cert.cert'</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a service (the app object is just a callback).</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an HTTP service.</span></span><br><span class="line">http.createServer(app).listen(<span class="number">80</span>);</span><br><span class="line"><span class="comment">// Create an HTTPS service identical to the HTTP service.</span></span><br><span class="line">https.createServer(options, app).listen(<span class="number">443</span>);</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-SSL-인증서-Letsencrypt&quot;&gt;&lt;a href=&quot;#1-SSL-인증서-Letsencrypt&quot; class=&quot;headerlink&quot; title=&quot;1. SSL 인증서, Letsencrypt&quot;&gt;&lt;/a&gt;1. SSL 인증서, Letsencry
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="node.log" scheme="https://ddok2.github.io/categories/dev/node-log/"/>
    
    
      <category term="nodejs" scheme="https://ddok2.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>PRPL 패턴</title>
    <link href="https://ddok2.github.io/2018/01/29/prpl-pattern/"/>
    <id>https://ddok2.github.io/2018/01/29/prpl-pattern/</id>
    <published>2018-01-29T00:15:30.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PRPL-패턴이란"><a href="#PRPL-패턴이란" class="headerlink" title="PRPL 패턴이란"></a>PRPL 패턴이란</h2><p>PRPL 은 다음의 약자입니다.</p><ul><li><code>Push</code>: 초기 URL 에서 가장 중요한 리소스만 푸시합니다.</li><li><code>Render</code>: 초기 경로를 먼저 렌더링 합니다.</li><li><code>Pre-cache</code>: 남은 경로를 사전에 미리 캐시합니다.</li><li><code>Lazy-load</code>: 요청에 따라 필요 시 남은 경로를 로드하고 다음 루트를 만들어 보여줍니다.</li></ul><p>PRPL은 PWA(Progressive Web App)의 목표와 표준을 추구하고 아래와 같은 경우에 최적화를 수행합니다.</p><ul><li>최소 상호작용 시간(Time-to-Interactive)<ul><li>최초 사용 시(진입점과 무관)</li><li>우리가 사용하는 휴대기기(핸드폰)에서</li></ul></li><li>업데이트가 릴리즈되는 동안 최대한의 캐싱 효율성</li><li>개발 및 배포의 단순성</li></ul><p>PRPL은 기술이나 기법보단 모바일 웹의 성능을 개선하려는 비전에 가깝습니다. Polymer 팀이 그 틀을 짜고 이름을 정한 후 <a href="https://www.youtube.com/watch?v=J4i0xJnQUzU" target="_blank" rel="noopener">Google I/O 2016</a>에 공개했습니다.</p><p>공개한 Polymer <a href="https://shop.polymer-project.org/" target="_blank" rel="noopener">Shop</a> E-커머셜 데모는 PRPL을 사용한 좋은 예시입니다. 이 데모는 실제 휴대기기에서 각 경로의 상호작용을 통해 놀라운 속도가 실현됩니다.</p><p>1.75초만에 나타나는 Polymer Shop 데모<br><img src="https://developers.google.com/web/fundamentals/performance/prpl-pattern/images/app-build-prpl-shop.jpg" alt=""></p><p>대부분의 프로젝트에서 PRPL 을 완전한 형태로 실현하기는 솔직히 말해 너무 이릅니다.<br>그러나 그러한 마음가짐을 갖거나 다양한 관점에서 비전을 추구하는 것은 절대로 너무 이른 것이 아닙니다.<br>오늘날 PRPL 를 구현하기 위해 앱 개발자, 도구 개발자 및 브라우저 공급업체가 따를 수 있는 유용한 단계들이 많이 있습니다.</p><h2 id="PRPL-을-가능하게-만드는-기술들"><a href="#PRPL-을-가능하게-만드는-기술들" class="headerlink" title="PRPL 을 가능하게 만드는 기술들"></a>PRPL 을 가능하게 만드는 기술들</h2><ul><li>HTTP/2 Server-push 지원 Web Server</li><li>Web Components 지원 플랫폼</li><li>Service Woker 지원 Web Browser</li></ul><h3 id="참조"><a href="#참조" class="headerlink" title="참조"></a>참조</h3><ul><li>PRPL 패턴 : <a href="https://developers.google.com/web/fundamentals/performance/prpl-pattern/" target="_blank" rel="noopener">https://developers.google.com/web/fundamentals/performance/prpl-pattern/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;PRPL-패턴이란&quot;&gt;&lt;a href=&quot;#PRPL-패턴이란&quot; class=&quot;headerlink&quot; title=&quot;PRPL 패턴이란&quot;&gt;&lt;/a&gt;PRPL 패턴이란&lt;/h2&gt;&lt;p&gt;PRPL 은 다음의 약자입니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Push&lt;
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="web.log" scheme="https://ddok2.github.io/categories/dev/web-log/"/>
    
    
      <category term="web" scheme="https://ddok2.github.io/tags/web/"/>
    
      <category term="prpl" scheme="https://ddok2.github.io/tags/prpl/"/>
    
  </entry>
  
  <entry>
    <title>Docker 명령어 정리</title>
    <link href="https://ddok2.github.io/2018/01/12/docker-command/"/>
    <id>https://ddok2.github.io/2018/01/12/docker-command/</id>
    <published>2018-01-12T00:27:53.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/dev/docker.log/docker-command.png" alt=""></p><h3 id="Docker-Hub에서-이미지-검색"><a href="#Docker-Hub에서-이미지-검색" class="headerlink" title="Docker Hub에서 이미지 검색"></a><a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>에서 이미지 검색</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker search ubuntu</span><br></pre></td></tr></table></figure><h3 id="Docker-Hub에서-이미지-받기"><a href="#Docker-Hub에서-이미지-받기" class="headerlink" title="Docker Hub에서 이미지 받기"></a>Docker Hub에서 이미지 받기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker pull ubuntu</span><br></pre></td></tr></table></figure><h3 id="Docker-이미지-목록-확인"><a href="#Docker-이미지-목록-확인" class="headerlink" title="Docker 이미지 목록 확인"></a>Docker 이미지 목록 확인</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker images</span><br></pre></td></tr></table></figure><h3 id="이미지로-컨테이너-실행-Run"><a href="#이미지로-컨테이너-실행-Run" class="headerlink" title="이미지로 컨테이너 실행(Run)"></a>이미지로 컨테이너 실행(Run)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -t -i --name sung-something ubuntu:lastest bin/bash</span><br></pre></td></tr></table></figure><ul><li>-i : 컨테이너와 상호작용</li><li>-t : tty(터미널)을 사용</li><li>-d : -i 옵션의 반대. 컨테이너를 백그라운드 실행</li><li>-p [외부포트]:[내부포트] : 포트포워딩 설정 ex) -p 80:8080 -&gt; 외부에서 들어온 80포트 요청을 컨테이너의 8080 포트로 포워딩시킨다. 포트를 여러개 열고 싶으면 -p 80:8080 -p 8088:8088 -p 27017:27017 이런식으로 이어서 쓰면 된다.</li><li>-v : [외부절대경로]:[내부절대경로] : 컨테이너 외부(호스트) 볼륨과 컨테이너 내부 볼륨을 바인딩시킨다.</li><li>-c : cpu 스케줄링 점유율 (기본값 1024)</li><li>-m : 메모리</li><li>-rm : 컨테이너가 종료되면 삭제</li><li>/bin/bash: 리눅스의 경우 컨테이너에서 bash 쉘을 이용</li></ul><h3 id="컨테이너-목록-확인"><a href="#컨테이너-목록-확인" class="headerlink" title="컨테이너 목록 확인"></a>컨테이너 목록 확인</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker ps</span><br></pre></td></tr></table></figure><ul><li>-a : 정지된 컨테이너까지 출력</li><li>-q : 컨테이너 ID만 출력</li></ul><h3 id="실행중인-컨테이너-shell에서-빠져나오기"><a href="#실행중인-컨테이너-shell에서-빠져나오기" class="headerlink" title="실행중인 컨테이너 shell에서 빠져나오기"></a>실행중인 컨테이너 shell에서 빠져나오기</h3><ul><li>exit : 쉘을 빠져나오면서 컨테이너를 종료</li><li>ctrl + p  + q 입력 : 컨테이너를 종료하지 않고 쉘만 빠져나옴</li></ul><h3 id="실행중인-컨테이너로-접속하기"><a href="#실행중인-컨테이너로-접속하기" class="headerlink" title="실행중인 컨테이너로 접속하기"></a>실행중인 컨테이너로 접속하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker attach sung-something</span><br></pre></td></tr></table></figure><h3 id="실행중인-컨테이너-정지하기"><a href="#실행중인-컨테이너-정지하기" class="headerlink" title="실행중인 컨테이너 정지하기"></a>실행중인 컨테이너 정지하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker stop sung-something</span><br></pre></td></tr></table></figure><h3 id="컨테이너-삭제하기"><a href="#컨테이너-삭제하기" class="headerlink" title="컨테이너 삭제하기"></a>컨테이너 삭제하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker rm sung-something</span><br></pre></td></tr></table></figure><ul><li>-f : 실행중인 컨테이너도 강제로 정지하고 삭제</li></ul><h3 id="컨테이너-모두-삭제하기"><a href="#컨테이너-모두-삭제하기" class="headerlink" title="컨테이너 모두 삭제하기"></a>컨테이너 모두 삭제하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Linux</span><br><span class="line">$ docker rm $(docker ps -a -q)</span><br><span class="line"></span><br><span class="line">## Windows</span><br><span class="line">&gt; FOR /f &quot;tokens=*&quot; %i IN (&apos;docker ps -a -q&apos;) DO docker rm %i</span><br></pre></td></tr></table></figure><h3 id="이미지-삭제하기"><a href="#이미지-삭제하기" class="headerlink" title="이미지 삭제하기"></a>이미지 삭제하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker rmi ubuntu:latest</span><br></pre></td></tr></table></figure><ul><li>[이미지 이름]:[태그] 형식을 사용해도 되고 이미지 ID를 사용해도 된다.</li><li>이미지 이름만 입력할 경우 태그에 관계없이 이미지 이름만 같으면 모두 삭제된다.</li></ul><h3 id="이미지-모두-삭제하기"><a href="#이미지-모두-삭제하기" class="headerlink" title="이미지 모두 삭제하기"></a>이미지 모두 삭제하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## Linux</span><br><span class="line">$ docker rmi $(docker images -q)</span><br><span class="line"></span><br><span class="line">## Windows</span><br><span class="line">&gt; FOR /f &quot;tokens=*&quot; %i IN (&apos;docker images -q -f &quot;dangling=true&quot;&apos;) DO docker rmi %i</span><br></pre></td></tr></table></figure><h3 id="컨테이너-변경사항-확인하기"><a href="#컨테이너-변경사항-확인하기" class="headerlink" title="컨테이너 변경사항 확인하기"></a>컨테이너 변경사항 확인하기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker diff [컨테이너 ID or NAME]</span><br></pre></td></tr></table></figure><p>어떤 이미지로 실행된 컨테이너 안의 내용의 변경되었다면, 버전 관리 시스템처럼 diff 명령어로 어떤 점이 바뀌었는지 확인할 수 있다.</p><h3 id="컨테이너로-이미지-만들기"><a href="#컨테이너로-이미지-만들기" class="headerlink" title="컨테이너로 이미지 만들기"></a>컨테이너로 이미지 만들기</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker commit [컨테이너 ID or NAME] [새로운 컨테이너 이름]:[태그]</span><br></pre></td></tr></table></figure><p>버전 관리 시스템처럼 commit 명령어로 변경된 컨테이너를 새로운 이미지로 만들 수 있다.</p><h3 id="Dockerfile을-통한-이미지-빌드"><a href="#Dockerfile을-통한-이미지-빌드" class="headerlink" title="Dockerfile을 통한 이미지 빌드"></a>Dockerfile을 통한 이미지 빌드</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker build -t [image name:tag] -f [Dockerfile 경로]</span><br></pre></td></tr></table></figure><h3 id="이미지-파일-Export"><a href="#이미지-파일-Export" class="headerlink" title="이미지 파일 Export"></a>이미지 파일 Export</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker save -o [내보낼 경로]/[내보낼 이름] [내보낼 이미지 ID or NAME]</span><br></pre></td></tr></table></figure><h3 id="이미지-파일-Import"><a href="#이미지-파일-Import" class="headerlink" title="이미지 파일 Import"></a>이미지 파일 Import</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo docker load -i [이미지 파일 경로]</span><br></pre></td></tr></table></figure><h3 id="볼륨-관련-명령어"><a href="#볼륨-관련-명령어" class="headerlink" title="볼륨 관련 명령어"></a>볼륨 관련 명령어</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 볼륨 만들기</span><br><span class="line">$ docker volume create [VOLUME NAME]</span><br><span class="line"></span><br><span class="line">## 볼륨 목록 보기</span><br><span class="line">$ docker volume ls</span><br><span class="line"></span><br><span class="line">## 특정 볼륨 상세정보 보기</span><br><span class="line">$ docker volume inspect [VOLUME ID or NAME]</span><br><span class="line"></span><br><span class="line">## 볼륨 삭제하기</span><br><span class="line">$ docker volume rm [VOLUME ID or NAME]</span><br><span class="line"></span><br><span class="line">## 사용하지 않는 볼륨 모두 삭제</span><br><span class="line">$ docker volume prune</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/dev/docker.log/docker-command.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;Docker-Hub에서-이미지-검색&quot;&gt;&lt;a href=&quot;#Docker-Hub에서-이미지-검색&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="docker.log" scheme="https://ddok2.github.io/categories/dev/docker-log/"/>
    
    
      <category term="docker" scheme="https://ddok2.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>NVM으로 노드 버전 관리하기</title>
    <link href="https://ddok2.github.io/2018/01/05/nvm-version-control/"/>
    <id>https://ddok2.github.io/2018/01/05/nvm-version-control/</id>
    <published>2018-01-05T02:30:06.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/dev/node.log/nvm-version-control.png" alt=""></p><p><a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">NVM</a>은 로컬에 다양한 버전의 노드를 설치할 수 있게 해주는 툴이다.</p><h2 id="설치"><a href="#설치" class="headerlink" title="설치"></a>설치</h2><p><a href="https://github.com/creationix/nvm#install-script" target="_blank" rel="noopener">NVM 문서</a>에 있는 설치 스크립트로 설치한다.</p><p>cURL:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>or Wget:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash</span><br></pre></td></tr></table></figure></p><p>설치하고 나면 profile(<code>~/.bash_profile</code>, <code>~/.zshrc</code>, <code>~/.profile</code>, <code>~/.bashrc</code>) 에 아래를 등록한다.</p><p>~/.bash_profile:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm</span><br></pre></td></tr></table></figure></p><p>Mac 같은 경우 <code>brew</code>로 설치한 경우:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NVM_DIR=&quot;$HOME/.nvm&quot;</span><br><span class="line">. &quot;/usr/local/opt/nvm/nvm.sh&quot; # This loads nvm</span><br></pre></td></tr></table></figure></p><p>그리고 <code>~/.nvm</code> 폴더를 생성한다.(만일 없으면 말이다.)</p><p>마지막으로:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ source ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p>잘 설치되었는지 확인:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ command -v nvm</span><br></pre></td></tr></table></figure></p><h2 id="명령어"><a href="#명령어" class="headerlink" title="명령어"></a>명령어</h2><p>NVM 에서 지원하는 노드 버전 확인:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nvm ls-remote</span><br></pre></td></tr></table></figure></p><p>로컬에 설치된 노드 확인:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nvm ls</span><br><span class="line"></span><br><span class="line">         v4.8.7</span><br><span class="line">         v6.12.2</span><br><span class="line">-&gt;       v8.9.3</span><br><span class="line">         system</span><br><span class="line">default -&gt; v8.9.3</span><br><span class="line">node -&gt; stable (-&gt; v8.9.3) (default)</span><br><span class="line">stable -&gt; 8.9 (-&gt; v8.9.3) (default)</span><br><span class="line">iojs -&gt; N/A (default)</span><br><span class="line">lts/* -&gt; lts/carbon (-&gt; v8.9.3)</span><br><span class="line">lts/argon -&gt; v4.8.7</span><br><span class="line">lts/boron -&gt; v6.12.2</span><br><span class="line">lts/carbon -&gt; v8.9.3</span><br></pre></td></tr></table></figure></p><p>해당 버전으로 변경:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nvm use v6.12.2</span><br></pre></td></tr></table></figure></p><p>해당 버전을 기본으로 변경:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nvm alias default system</span><br><span class="line">default -&gt; system</span><br></pre></td></tr></table></figure></p><h2 id="WebStorm-에서-이용하기"><a href="#WebStorm-에서-이용하기" class="headerlink" title="WebStorm 에서 이용하기"></a>WebStorm 에서 이용하기</h2><p>링크 생성:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd ~/.nvm/versions/node</span><br><span class="line">$ ln -s v6.12.2 default</span><br><span class="line">$ ls -ld default</span><br><span class="line"></span><br><span class="line">default@ -&gt; v6.12.2</span><br></pre></td></tr></table></figure></p><p>WebStorm 노드 경로 설정:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~/.nvm/version/node/default/bin/node</span><br></pre></td></tr></table></figure></p><p>node_modules 경로:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~/.nvm/version/node/default/lib/node_modules</span><br></pre></td></tr></table></figure></p><p>새로운 노드 버전 설치 후:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nvm install v6.12.3</span><br><span class="line">$ cd ~/.nvm/versions/node</span><br><span class="line">$ rm default</span><br><span class="line">$ ln -s v6.12.3 default</span><br></pre></td></tr></table></figure></p><p>해당 자료는 <a href="https://github.com/ddok2/TIL/blob/master/nodejs/nvm-version-control.md" target="_blank" rel="noopener">https://github.com/ddok2/TIL/blob/master/nodejs/nvm-version-control.md</a> 에 작성된 자료이다.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/dev/node.log/nvm-version-control.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/creationix/nvm&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="node.log" scheme="https://ddok2.github.io/categories/dev/node-log/"/>
    
    
      <category term="nodejs" scheme="https://ddok2.github.io/tags/nodejs/"/>
    
      <category term="nvm" scheme="https://ddok2.github.io/tags/nvm/"/>
    
  </entry>
  
  <entry>
    <title>Node.js Security Overview</title>
    <link href="https://ddok2.github.io/2018/01/04/nodejs-security-overview/"/>
    <id>https://ddok2.github.io/2018/01/04/nodejs-security-overview/</id>
    <published>2018-01-04T00:17:07.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/ddok2/TIL/blob/master/nodejs/nodejs-security-overview.md" target="_blank" rel="noopener">해당 자료</a>는 <a href="https://github.com/ddok2/TIL/blob/master/nodejs/nodejs-security-overview.md" target="_blank" rel="noopener">https://github.com/ddok2/TIL/blob/master/nodejs/nodejs-security-overview.md</a><br>에 작성된 자료이다.</p><h2 id="Security-in-the-NPM-ecosystem"><a href="#Security-in-the-NPM-ecosystem" class="headerlink" title="Security in the NPM ecosystem"></a>Security in the NPM ecosystem</h2><ul><li><a href="http://blog.npmjs.org/post/142077474335/npm-registry-is-now-fully-https" target="_blank" rel="noopener">Moving the whole traffic of the registry to HTTPS</a></li><li><a href="http://blog.npmjs.org/post/166039777883/protect-your-npm-account-with-two-factor" target="_blank" rel="noopener">Protect your npm account with two-factor authentication and read-only tokens</a></li><li><a href="https://docs.npmjs.com/getting-started/using-two-factor-authentication" target="_blank" rel="noopener">Using Two-Factor Authentication</a></li></ul><h2 id="Securing-your-Node-js-applications"><a href="#Securing-your-Node-js-applications" class="headerlink" title="Securing your Node.js applications"></a>Securing your Node.js applications</h2><h3 id="Using-the-Helmet-module"><a href="#Using-the-Helmet-module" class="headerlink" title="Using the Helmet module"></a><a href="https://www.npmjs.com/package/helmet" target="_blank" rel="noopener">Using the Helmet module</a></h3><p><a href="https://www.npmjs.com/package/helmet" target="_blank" rel="noopener">Helmet</a>을 이용하면 웹 취약성으로부터 앱을 보호할 수 있다.</p><ul><li><a href="https://github.com/helmetjs/csp" target="_blank" rel="noopener">csp</a>는 Content-Security-Policy 헤더를 설정하여 XSS(Cross-site scripting) 공격 및 기타 교차 사이트 인젝션을 예방한다.</li><li><a href="https://github.com/helmetjs/hide-powered-by" target="_blank" rel="noopener">hidePoweredBy</a>는 X-Powered-By 헤더를 제거한다.</li><li><a href="https://github.com/helmetjs/hpkp" target="_blank" rel="noopener">hpkp</a>는 Public Key Pinning 헤더를 추가하여, 위조된 인증서를 이용한 중간자 공격을 방지한다.</li><li><a href="https://github.com/helmetjs/hsts" target="_blank" rel="noopener">hsts</a>는 서버에 대한 안전한(SSL/TLS를 통한 HTTP) 연결을 적용하는 Strict-Transport-Security 헤더를 설정한다.</li><li><a href="https://github.com/helmetjs/ienoopen" target="_blank" rel="noopener">ieNoOpen</a>은 IE8 이상에 대해 X-Download-Options를 설정한다.</li><li><a href="noCache">noCache</a>는 Cache-Control 및 Pragma 헤더를 설정하여 클라이언트 측에서 캐싱을 사용하지 않도록 한다.</li><li><a href="https://github.com/helmetjs/dont-sniff-mimetype" target="_blank" rel="noopener">noSniff</a>는 X-Content-Type-Options 를 설정하여, 선언된 콘텐츠 유형으로부터 벗어난 응답에 대한 브라우저의 MIME 가로채기를 방지한다.</li><li><a href="https://github.com/helmetjs/frameguard" target="_blank" rel="noopener">frameguard</a>는 X-Frame-Options 헤더를 설정하여 clickjacking에 대한 보호를 제공한다.</li><li><a href="https://github.com/helmetjs/x-xss-protection" target="_blank" rel="noopener">xssFilter</a>는 X-XSS-Protection을 설정하여 대부분의 최신 웹 브라우저에서 XSS(Cross-site scripting) 필터를 사용하도록 한다.</li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i helmet -S</span><br></pre></td></tr></table></figure><p>이후 코드에서 Helmet을 사용하는 방법은 다음과 같다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> helmet = <span class="built_in">require</span>(<span class="string">'helmet'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line">app.use(helmet());</span><br></pre></td></tr></table></figure></p><p>X-Powered-By헤더를 사용하지 않기<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">app.disabled(<span class="string">'x-powered-by'</span>);</span><br></pre></td></tr></table></figure></p><p>물론 Helmet를 이용하면 자동으로 위의 작업을 한다.</p><h3 id="Validating-user-input"><a href="#Validating-user-input" class="headerlink" title="Validating user input"></a>Validating user input</h3><ul><li>command injection</li><li>SQL injection</li><li>stored cross-site scripting</li></ul><p>위 항목을 피하기 위해서 사용자 입력을 유효성검사를 해야한다.<br>사용자 유효성 검사하기에 좋은 라이브러리는 <a href="https://www.npmjs.com/package/joi" target="_blank" rel="noopener">Joi</a>이다.</p><p>사용방법은 다음과 같다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Joi = <span class="built_in">require</span>(<span class="string">'joi'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> schema = Joi.object().keys(&#123;</span><br><span class="line">    username: Joi.string().alphanum().min(<span class="number">3</span>).max(<span class="number">30</span>).required(),</span><br><span class="line">    password: Joi.string().regex(<span class="regexp">/^[a-zA-Z0-9]&#123;3,30&#125;$/</span>),</span><br><span class="line">    access_token: [Joi.string(), Joi.number()],</span><br><span class="line">    birthyear: Joi.number().integer().min(<span class="number">1900</span>).max(<span class="number">2013</span>),</span><br><span class="line">    email: Joi.string().email()</span><br><span class="line">&#125;).with(<span class="string">'username'</span>, <span class="string">'birthyear'</span>).without(<span class="string">'password'</span>, <span class="string">'access_token'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Return result.</span></span><br><span class="line"><span class="keyword">const</span> result = Joi.validate(&#123; </span><br><span class="line">        username: <span class="string">'abc'</span>, </span><br><span class="line">        birthyear: <span class="number">1994</span> </span><br><span class="line">    &#125;, schema);</span><br><span class="line"><span class="comment">// result.error === null -&gt; valid</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// You can also pass a callback which will be called synchronously with the validation result.</span></span><br><span class="line">Joi.validate(&#123; </span><br><span class="line">        username: <span class="string">'abc'</span>, </span><br><span class="line">        birthyear: <span class="number">1994</span> </span><br><span class="line">    &#125;, schema, <span class="function"><span class="keyword">function</span> (<span class="params">err, value</span>) </span>&#123; &#125;);  <span class="comment">// err === null -&gt; valid</span></span><br></pre></td></tr></table></figure></p><h2 id="Secure-Coding-Style"><a href="#Secure-Coding-Style" class="headerlink" title="Secure Coding Style"></a>Secure Coding Style</h2><h3 id="Do-not-use-eval"><a href="#Do-not-use-eval" class="headerlink" title="Do not use eval()"></a>Do not use <strong><em>eval()</em></strong></h3><p>Eval은 애플리케이션에 코드 인젝션 공격을 가능하게 한다. 이를 사용하려고 하지마라.</p><p><strong><em>eval()</em></strong> 뿐만 아니라 아래의 표현도 피해야한다. 아래의 표현은 백그라운드로 <strong><em>eval()</em></strong> 를 사용한다.</p><ul><li><strong><em>setInterval(String, 2)</em></strong></li><li><strong><em>setTimeout(String, 2)</em></strong></li><li><strong><em>new Function(String)</em></strong></li></ul><h3 id="Always-use-use-strict"><a href="#Always-use-use-strict" class="headerlink" title="Always use use strict;"></a>Always use <strong><em>use strict;</em></strong></h3><p><strong><em>use strict;</em></strong> 를 사용하면 자바스크립트의 “변종”을 허용하지 않게 한다. 또한 몇몇 암묵적인 에러들을 제거해주고 에러로그를 throw한다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> sung = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="Set-cookie-scope"><a href="#Set-cookie-scope" class="headerlink" title="Set cookie scope"></a>Set cookie scope</h3><p>쿠키로 인해 앱이 악용에 노출되지 않도록 하기 위해 기본 세션 쿠키 이름을 사용하지 말고 쿠키 보안 옵션을 적절히 설정한다.</p><h4 id="기본-세션-쿠키-이름을-사용하지-않음"><a href="#기본-세션-쿠키-이름을-사용하지-않음" class="headerlink" title="기본 세션 쿠키 이름을 사용하지 않음"></a>기본 세션 쿠키 이름을 사용하지 않음</h4><p>기본 세션 쿠키 이름을 사용하면 앱을 공격에 노출시킬 수 있다. </p><p>이로 인해 제기되는 보안 문제는 X-Powered-By와 유사하며, 잠재적인 공격자는 이를 이용해 서버의 지문을 채취한 후 이에 따라 공격 대상을 설정할 수 있다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'express-session'</span>);</span><br><span class="line"></span><br><span class="line">app.set(<span class="string">'trust proxy'</span>, <span class="number">1</span>); <span class="comment">// trust first proxy</span></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    secret: <span class="string">'s3Cur3'</span>,</span><br><span class="line">    name: <span class="string">'sessionId'</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h4 id="쿠키-보안-옵션-설정"><a href="#쿠키-보안-옵션-설정" class="headerlink" title="쿠키 보안 옵션 설정"></a>쿠키 보안 옵션 설정</h4><p>다음과 같은 쿠키 옵션을 설정하여 보안을 강화할 필요가 있다.</p><ul><li>secure - 브라우저가 HTTPS를 통해서만 쿠키를 전송하도록 한다.</li><li>httpOnly - 쿠키가 클라이언트 JavaScript가 아닌 HTTP(S)를 통해서만 전송되도록 하며, 이를 통해 XSS(Cross-site scripting) 공격으로부터 보호할 수 있다.</li><li>domain - 쿠키의 도메인을 표시하고 URL이 요청되고 있는 서버의 도메인에 대해 비교할 때 사용한다. 두 도메인이 일치하는 경우에는 그 다음으로 경로 속성을 확인해라.</li><li>path - 쿠키의 경로를 표시한다. 요청 경로에 대해 비교할 때 사용하며 이 경로와 도메인이 일치하는 경우에는 요청되고 있는 쿠키를 전송한다.</li><li>expires - 지속적 쿠키에 대한 만기 날짜를 설정하는 데 사용된다.</li></ul><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> session = <span class="built_in">require</span>(<span class="string">'cookie-session'</span>);</span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> expiryDate = <span class="keyword">new</span> <span class="built_in">Date</span>( <span class="built_in">Date</span>.now() + <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span> ); <span class="comment">// 1 hour</span></span><br><span class="line"></span><br><span class="line">app.use(session(&#123;</span><br><span class="line">    name: <span class="string">'session'</span>,</span><br><span class="line">    keys: [<span class="string">'key1'</span>, <span class="string">'key2'</span>],</span><br><span class="line">    cookie: &#123; </span><br><span class="line">        secure: <span class="literal">true</span>,</span><br><span class="line">        httpOnly: <span class="literal">true</span>,</span><br><span class="line">        domain: <span class="string">'example.com'</span>,</span><br><span class="line">        path: <span class="string">'foo/bar'</span>,</span><br><span class="line">        expires: expiryDate</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="Audit-your-modules-with-the-Node-Security-Platform"><a href="#Audit-your-modules-with-the-Node-Security-Platform" class="headerlink" title="Audit your modules with the Node Security Platform"></a>Audit your modules with the Node Security Platform</h3><p><a href="https://www.npmjs.com/package/nsp" target="_blank" rel="noopener">nsp</a>는 Node Security Platform의 주요 커맨드라인 인터페이스이다.<br>nsp는 취약한 모듈들을 점검하기 위해 package.json 파일 혹은 npm-shirnkwrap.json 파일을 NSP API를 통해 감시한다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i nsp -g</span><br><span class="line"></span><br><span class="line"># From inside your project directory</span><br><span class="line"></span><br><span class="line">$ nsp check</span><br></pre></td></tr></table></figure><p>유효성 검증을 위한 npm-shrinkwrap.json 파일을 <a href="https://nodesecurity.io/" target="_blank" rel="noopener">nodesecurity.io</a>에 제출하려면 다음과 같은 명령을 사용한다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nsp audit-shrinkwrap</span><br></pre></td></tr></table></figure></p><p>유효성 검증을 위한 package.json 파일을 <a href="https://nodesecurity.io/" target="_blank" rel="noopener">nodesecurity.io</a>에 제출하려면 다음과 같은 명령을 사용한다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nsp audit-package</span><br></pre></td></tr></table></figure></p><h3 id="Look-for-vulnerabilities-with-Retire-js"><a href="#Look-for-vulnerabilities-with-Retire-js" class="headerlink" title="Look for vulnerabilities with Retire.js"></a>Look for vulnerabilities with <a href="https://github.com/RetireJS/retire.js" target="_blank" rel="noopener">Retire.js</a></h3><p><a href="https://github.com/RetireJS/retire.js" target="_blank" rel="noopener">Retire.js</a>는 사용하고 있는 모듈 버전들에 대해 알려진 취약점을 탐지해주기 위한 모듈이다.</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ npm i retire -g</span><br></pre></td></tr></table></figure><p>retire 명령으로 실행하면 node_modules 디렉토리내의 모듈들의 취약점을 찾을 수 있다.</p><p>(또한 참고로 retire.js는 node_modules 외에 프론트엔드 라이브러리에서도 잘 작동한다.)</p><h4 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h4><ul><li><a href="https://nemethgergely.com/nodejs-security-overview/" target="_blank" rel="noopener">Node.js Security Overview (17.10.12)</a></li><li><a href="http://expressjs.com/en/advanced/best-practice-security.html" target="_blank" rel="noopener">Production Best Practices: Security</a></li><li><a href="https://blog.risingstack.com/node-hero-node-js-security-tutorial/" target="_blank" rel="noopener">Node.js Security Tutorial</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/ddok2/TIL/blob/master/nodejs/nodejs-security-overview.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;해당 자료&lt;/a&gt;는 &lt;a href=&quot;
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="node.log" scheme="https://ddok2.github.io/categories/dev/node-log/"/>
    
    
      <category term="nodejs" scheme="https://ddok2.github.io/tags/nodejs/"/>
    
      <category term="security" scheme="https://ddok2.github.io/tags/security/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 개발시 주의사항 10가지 (3년전 이야기)</title>
    <link href="https://ddok2.github.io/2018/01/03/top10-common-mistakes/"/>
    <id>https://ddok2.github.io/2018/01/03/top10-common-mistakes/</id>
    <published>2018-01-03T01:21:49.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<p>이글은 Need Node.js Help? Check These Top 10 Common Node.js Developer Mistakes 제목으로 MAHMUD RIDWAN 이란 개발자가 쓴 Node.js로 개발하면서 발생하는 10가지 실수들에 대한 내용입니다.</p><p><a href="https://www.toptal.com/nodejs/top-10-common-nodejs-developer-mistakes" target="_blank" rel="noopener">원문</a>에서 확인 하시면 됩니다.</p><h2 id="Mistake-1-이벤트-루프의-블록킹"><a href="#Mistake-1-이벤트-루프의-블록킹" class="headerlink" title="Mistake #1: 이벤트 루프의 블록킹"></a>Mistake #1: 이벤트 루프의 블록킹</h2><p>Node.js의 자바스크립트의 경우(브라우저와 마찬가지로) 싱글 쓰레드 방식의 환경입니다. 이 말은 우리가 어플리케이션을 만들면 두 개의 작업을 병렬로 진행하는 것이 불가능하다는 말입니다. 대신에 IO기반으로 비동기적으로 동시에 발생하는 여러 작업들을 다루고 있습니다.<br>예를들면 Node.js가 데이터베이스의 데이터를 가져오는 작업을 요청을 한다면 데이터를 가져오는 동안 어플리케이션의 다른 일에 집중 할 수 있다는 말입니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">db.User.get(userId, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 여기에 실제로 데이터가 불러와 지는 동안은 다른 일을 합니다.</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>그런데 만약에 CPU 기반의 코드를 작성한다고 가정을 해보겠습니다. 예를 들어 엄청나게 큰 배열을 sorting 하는 작업이나 엄청나게 큰 loop를 도는 작업을 하는 작업들이 있을 수 있습니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortUsersByAge</span>(<span class="params">users</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">           users.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">return</span> a.age &lt; b.age ? <span class="number">-1</span> : <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 형태의 코드가 실제로 문제가 될 수 있습니다. 이 경우에는 적은 수의 사용자라면 별로 문제가 되지 않을 테지만 수천 수만 명이 동시에 접속해서 동일한 작업을 요청하게 된다면 다른 작업이 마칠 때까지 다른 사용자들은 결과를 기다릴 수 밖에 없는 문제가 발생합니다. 결국 callback을 통한 비 동기적인 코드의 효과가 전혀 없어지게 됩니다.</p><p>위와 같은 문제를 해결하는 가장 이상적인 해결책은 이미 sorting이 된 결과를 DB상에서 처리해서 내려주는 것입니다.</p><p>실제로 Nodejs에서는 이 문제를 해결할만한 명확한 해결책은 없습니다. DB에서 최대한 처리된 데이터를 내려다 준다 던지 하는 각 상황에 맞춰 해결하는 수밖에 없습니다.</p><p>우리는 오직 하나 그저 CPU에 지나치게 의존하는 작업들을 피하라는 것입니다.</p><h2 id="Mistake-2-한번-이상의-Callback-함수의-실행"><a href="#Mistake-2-한번-이상의-Callback-함수의-실행" class="headerlink" title="Mistake #2: 한번 이상의 Callback 함수의 실행"></a>Mistake #2: 한번 이상의 Callback 함수의 실행</h2><p>자바스크립트는 callback에 의존하고 있습니다. 브라우저상에서 이벤트를 처리하기 위해서 참조된 함수를 넘기거나 또는 익명의 함수를 선언하여 callback을 구현하고 있습니다.</p><p>Node.js 에서는 callback이 비동기적인 코드가 각각 통신하는 유일한 방법입니다. ES6의 promise 기법이 소개 되기 전까지는 말이지요. promise 기법에 대한 정보는 <a href="https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html?utm_source=javascriptweekly&amp;utm_medium=email" target="_blank" rel="noopener">이곳</a> 에서 얻으실 수 있습니다.</p><p>callback은 여전히 많은 수의 개발자들이 API를 설계할 때 callback을 기반으로 설계를 하고 있습니다. 여기서 문제는 바로 이 callback함수가 의도치 않게 한번 이상 호출이 되는 경우가 있다는 것입니다.</p><p>일반적으로 함수의 제일 마지막 매개변수에 비동기적으로 무언가를 하게 하기 위한 무언가를 전달하고 그 무언가는 해당 함수의 요청이 완료가 되면 실행이 되는 방식입니다. 일반적인 callback의 방식입니다.</p><p>아래의 코드를 보기겠습니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports.verifyPassword = <span class="function"><span class="keyword">function</span>(<span class="params">user, password, done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">typeof</span> password !== <span class="string">'string'</span>) &#123;</span><br><span class="line"></span><br><span class="line">                     done(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'password should be a string'</span>));</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           computeHash(password, user.passwordHashOpts, <span class="function"><span class="keyword">function</span>(<span class="params">err, hash</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                                done(err);</span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     done(<span class="literal">null</span>, hash === user.passwordHash);</span><br><span class="line"></span><br><span class="line">           &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>return</code> 문이 마지막에는 매번 <code>done</code>을 호출하는지 보시기 바랍니다. 이는 현재의 함수의 실행의 마지막 부분에 자동으로 callback 함수를 실행하지 않기 때문에 반드시 <code>callback()</code>를 호출을 해줘야 합니다. 즉 해당 함수가 끝이 났다는 말입니다.</p><p>그런데 위의 코드의 경우에 password로 string이 아닌 값을 넘기게 된다면 “password should be a string” 라는 문구를 리턴하게 될 것입니다. 그리고 코드가 끝이 나야 합니다. 하지만 위의 함수는 computeHash라는 함수로 진입을 하게 됩니다.</p><p>즉, 함수가 끝이 났음을 인지하지 못하고 있습니다. 결국 <code>callback()</code>가 두 번이나 호출이 되어 우리가 원하는 형태의 함수 로직을 구현할 수 가 없게 되었습니다.</p><p>위와 같은 Nodejs의 에러를 피하기 위해서 개발자들은 반드시 <code>callback()</code> 앞에 <code>return</code>을 붙이는 습관이 필요합니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span>(err) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> done(err);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 형태로 말입니다. 많은 비동기적인 함수들의 return 값들은 대부분 의미를 가지지 않습니다. 반드시 return에 콜백함수를 넘겨</p><p>그래서 이러한 습관은 위에서 발생한 문제를 피하는 가장 쉬운 방법입니다.</p><h2 id="Mistake-3-꼬리에-꼬리를-무는-Callback-함수"><a href="#Mistake-3-꼬리에-꼬리를-무는-Callback-함수" class="headerlink" title="Mistake #3: 꼬리에 꼬리를 무는 Callback 함수"></a>Mistake #3: 꼬리에 꼬리를 무는 Callback 함수</h2><p>callback – hell 이라고 불리는 꼬리에 꼬리를 무든 callback 함수의 연결입니다. 이는 Nodejs 그 자체의 문제는 아니지만 자칫하다가는 코드의 흐름이 엉망이 되는 원인이 됩니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLogin</span>(<span class="params">..., done</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">           db.User.get(..., <span class="function"><span class="keyword">function</span>(<span class="params">..., user</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">if</span>(!user) &#123;</span><br><span class="line">                                <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="string">'failed to log in'</span>);</span><br><span class="line"></span><br><span class="line">                     &#125;</span><br><span class="line"></span><br><span class="line">                     utils.verifyPassword(..., <span class="function"><span class="keyword">function</span>(<span class="params">..., okay</span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">if</span>(okay) &#123;</span><br><span class="line"></span><br><span class="line">                                          <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="string">'failed to log in'</span>);</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                session.login(..., <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                                          done(<span class="literal">null</span>, <span class="string">'logged in'</span>);</span><br><span class="line"></span><br><span class="line">                                &#125;);</span><br><span class="line">                     &#125;);</span><br><span class="line">           &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>이런 코드는 유지보수는 물론 코드의 가독성 마저 낮춰버리는 경향이 있습니다. 이 문제를 해결하는 방법은 꽤나 간단합니다. 기능별로 함수를 정의 하여 함수끼리 연결을 시키는 것입니다.</p><p>하지만 무엇보다 가장 깔끔한 해결책 중에 하나는 Nodejs 패키지중에 자바스크립트의 비동기 패턴을 다뤄주는 유틸리리티인 Async.js 를 사용하는 것입니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleLogin</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">async</span>.waterfall([</span><br><span class="line">                     <span class="function"><span class="keyword">function</span>(<span class="params">done</span>) </span>&#123;</span><br><span class="line">                                db.User.get(..., done);</span><br><span class="line">                     &#125;,</span><br><span class="line">                     <span class="function"><span class="keyword">function</span>(<span class="params">user, done</span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">if</span>(!user) &#123;</span><br><span class="line">                                <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="string">'failed to log in'</span>);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                utils.verifyPassword(..., <span class="function"><span class="keyword">function</span>(<span class="params">..., okay</span>) </span>&#123;</span><br><span class="line">                                          done(<span class="literal">null</span>, user, okay);</span><br><span class="line">                                &#125;);</span><br><span class="line">                     &#125;,</span><br><span class="line"></span><br><span class="line">                     <span class="function"><span class="keyword">function</span>(<span class="params">user, okay, done</span>) </span>&#123;</span><br><span class="line">                                <span class="keyword">if</span>(okay) &#123;</span><br><span class="line"></span><br><span class="line">                                          <span class="keyword">return</span> done(<span class="literal">null</span>, <span class="string">'failed to log in'</span>);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                session.login(..., <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                                          done(<span class="literal">null</span>, <span class="string">'logged in'</span>);</span><br><span class="line"></span><br><span class="line">                                &#125;);</span><br><span class="line">                     &#125;</span><br><span class="line">           ], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                     <span class="comment">// ...</span></span><br><span class="line">           &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>위의 코드는 하나의 예일뿐 다양한 패턴에 맞춰 다양한 메서드를 지원하니 사이트에 방문하셔서 더 많은 정보를 얻으시기 바랍니다.</p><h2 id="Mistake-4-Callback-함수가-동기적으로-동작하길-기대함"><a href="#Mistake-4-Callback-함수가-동기적으로-동작하길-기대함" class="headerlink" title="Mistake #4: Callback 함수가 동기적으로 동작하길 기대함"></a>Mistake #4: Callback 함수가 동기적으로 동작하길 기대함</h2><p>callback을 통한 비동기적인 프로그래밍은 자바스크립트와 Nodejs의 꽤나 특별한 방식입니다.  다른 프로그래밍 언어에서는 실행의 순서를 예측하는데 익숙합니다. 두개의 실행문이 있으면 하나가 실행이 되면 다른 하나가 다음에 실행이 되는 방식으로 별다른 지시가 없다면 문장을 건너뛰고 하는 일은 없을 것입니다.</p><p>만약 이런 뛰어 넘는 일이 발생하더라도 조건문, 반복문, 함수의 호출등 으로 제한이 있습니다.</p><p>하지만 자바스크립트에서는 콜백의 특정 기능이 해당 함수가 끝이 날 때까지 실행되지 않는 경우도 있을 수 있습니다. 현재 함수의 실행의 중단 없이 그냥 끝까지 실행이 됩니다. 예를 들면 아래와 같은 코드입니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testTimeout</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="built_in">console</span>.log(“Begin”);</span><br><span class="line"></span><br><span class="line">           setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">                     <span class="built_in">console</span>.log(“Done!”);</span><br><span class="line"></span><br><span class="line">           &#125;, duration * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">           <span class="built_in">console</span>.log(“Waiting..”);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>testTimeout이라는 함수가 실행이되면 우선 Begin이라는 글이 찍히고 다음으로는 Waiting.. 그리고 1초가 지난 후에애 Done! 이라는 글자가 찍히게 됩니다.</p><p>콜백이 실행되고 다음에 발생해야하는 무언가는 반드시 콜백함수 안에서 다뤄야만 합니다.</p><h2 id="Mistake-5-module-exports-대신에-exports를-선언함"><a href="#Mistake-5-module-exports-대신에-exports를-선언함" class="headerlink" title="Mistake #5: module.exports 대신에 exports를 선언함."></a>Mistake #5: module.exports 대신에 exports를 선언함.</h2><p>Node.js의 경우에는 각각의 파일을 고립된 작은 모듈로 취급을 합니다. 만약에 여러분의 패키지가 a.js와 b.js 라는 두개의 파일로 구성이 되어있다고 하겠습니다.  이때 b.js가 기능적으로 a.js에 접근을 해야하는 경우 a.js는 반드시 export 객체의 프로퍼티로 추가되어 있어야 합니다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"></span><br><span class="line">exports.verifyPassword = <span class="function"><span class="keyword">function</span>(<span class="params">user, password, done</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure><p>이 코드를 통해서 누구든지 a.js를 require 만 시켜주면 객체의 프로퍼티 함수로 verifyPassword 를 사용하는 것이 가능합니다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'a.js'</span>) <span class="comment">// &#123; verifyPassword: function(user, password, done) &#123; ... &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>하지만 만약에 verifyPassword 함수를 어떠한 객체의 프로퍼티가 아닌 직접적으로 export시키고 싶은 경우는 어떻게 해야 할까요?<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">user, password, done</span>) </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>exports를 모듈 객체의 프로퍼티로 다루고 있습니다. 여기서 우리는 exports와 module.exports를 구분하는 것이 매우 중요합니다.</p><p>간략히 요약을 하면 module.export를 사용하면 export객체에 선언된 모든 정보들은 무시하고 가장 우선적으로 정보가 선택이됩니다.</p><h2 id="Mistake-6-함수의-에러를-Callback-함수-내부로-던져버림"><a href="#Mistake-6-함수의-에러를-Callback-함수-내부로-던져버림" class="headerlink" title="Mistake #6: 함수의 에러를 Callback 함수 내부로 던져버림"></a>Mistake #6: 함수의 에러를 Callback 함수 내부로 던져버림</h2><p>자바스크립트는 예외처리의 개념이 존재합니다. 이는 거의 전통적인 언어 ,예를 들면 Java, C++ 같은 언어처럼 예외를 다루는 기능을 제공합니다. 자바스크립트는 try-catch 블록을 통해 에러를 throw하고 catch하는 것이 가능합니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">slugifyUsername</span>(<span class="params">username</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">typeof</span> username === <span class="string">'string'</span>) &#123;</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'expected a string username, got '</span>+(<span class="keyword">typeof</span> username));</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">var</span> usernameSlug = slugifyUsername(username);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">           <span class="built_in">console</span>.error(<span class="string">'Oh no!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>하지만 try-catch의 경우에는 비동기적인 상황에서는 여러분이 기대하는 대로 동작을 하지않을것입니다. 예를들어 비동기적인 기능을 가진 엄청나게 긴 코드를 하나의 큰 try-catch 구문에 묶어서 코드를 안정적으로 구현하고자 하지만 실제로는 기대한 대로 동작하지 않습니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">           db.User.get(userId, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">                     <span class="keyword">if</span>(err) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> err</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// ...</span></span><br><span class="line">                     usernameSlug = slugifyUsername(user.username);</span><br><span class="line">                     <span class="comment">// ...</span></span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">           <span class="built_in">console</span>.log(<span class="string">'Oh no!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>db.User.get 의 콜백이 비동기적으로 실행이 되면, 해당 콜백 함수의 스코프안의 try-catch문에서 에러를 처리하게 될 것입니다. 즉 에러가 발생했지만 그 에러를 콜백함수 내에서 처리한다는 말입니다. 즉, 에러를 처리하러 catch문으로 들어갈 일이 없다는 말입니다.<br>이게 Node.js가 에러를 다루는 조금은 다른 방식입니다. 그래서 반드시 콜백함수는 (err, …) 과 같은 패턴으로 인자를 다룹니다. 첫 번째 인자는 반드시 에러가 발생하면 에러를 다루는 인자가 전달되어야 합니다.</p><h2 id="Mistake-7-모든-숫자가-정수형이라는-착각"><a href="#Mistake-7-모든-숫자가-정수형이라는-착각" class="headerlink" title="Mistake #7: 모든 숫자가 정수형이라는 착각"></a>Mistake #7: 모든 숫자가 정수형이라는 착각</h2><p>자바스크립트에서의 숫자는 소수점을 가진 숫자입니다. 실제도 정수형 데이터 타입은 존재하지 않습니다. 여러분은 이게 어떤 문제가 되는 것을 원치 않을 것입니다.<br>우리가 보는 숫자는 실제로 정수부분만을 우리가 보는 것이고 뒤에는 우리가 보지 못하는 소수부분을 감추고 있습니다. 그러다 보니 숫자를 계산하다 보면 우리가 원치 않은 결과를 만들어 내는 경우가 있습니다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.pow(2, 53)+1 === Math.pow(2, 53)</span><br></pre></td></tr></table></figure></p><p>실제 논리적으로는 말이 안되지만 Node.js(자바스크립트) 상에서는 true 로 리턴이 됩니다. 못 믿으시겠다면 당장 브라우저의 콘솔창을 띄우시고 확인해보시기 바랍니다.<br>이런 자바스크립트가 숫자를 다루는 부분에 있어서의 문제는 여기서 끝이 아닙니다. 심지어 부동소숫점을 가진 숫자라도 정수를 다루던 연산자가 동일하게 동작을 합니다.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 % 2 === 1 // true</span><br><span class="line"></span><br><span class="line">5 &gt;&gt; 1 === 2 // true</span><br></pre></td></tr></table></figure></p><p>하지만 산수를 하던 연산자와는 달리 비트단위를 다루는 연산자나 시프트를 다루는 연산자의 경우에는 매우 큰 정수에 대해서 오직 마지막의 32bit까지만 인지하고 동작을 합니다. 예를들면<br><code>Math.pow(2, 53)</code> 를 1만큼 시프트시키는 연산을 진행하면 결과는 항상 0입니다. 그리고 or 로 비트단위 연산자를 시행하면 항상 1을 결과값으로 내놓습니다.</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) / <span class="number">2</span> === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">52</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) &gt;&gt; <span class="number">1</span> === <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) | <span class="number">1</span> === <span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>즉, 큰 정수를 다룰 때는 우리가 생각하는 정수가 아닌 수가 된다는 말입니다. 실제로 이렇게 큰 수들을 다룰 일은 거의 없지만 그래도 큰 수를 다루게 된다면 많은 수의 라이브러리들이 큰수를 문제없이 동작하게 만들어 주고 있습니다. 예를들면 bignum 같은 라이브러리들이 있습니다.</p><h2 id="Mistake-8-Streaming-APIs의-장점을-무시함"><a href="#Mistake-8-Streaming-APIs의-장점을-무시함" class="headerlink" title="Mistake #8: Streaming APIs의 장점을 무시함"></a>Mistake #8: Streaming APIs의 장점을 무시함</h2><p>우선 작은 프록시 서버를 만들기로 하죠. 서버는 간단하게 요청이 오면 다른 웹 서버의 컨텐츠를 가져오는 역할을 할 것입니다. 예제는 Gravatar 서버로부터 아바타 이미지를 가져오는 작업을 합니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"></span><br><span class="line">http.createServer()</span><br><span class="line"></span><br><span class="line">.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> email = req.url.substr(req.url.lastIndexOf(<span class="string">'/'</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(!email) &#123;</span><br><span class="line">                     res.writeHead(<span class="number">404</span>);</span><br><span class="line">                     <span class="keyword">return</span> res.end();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">1024</span>*<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">           http.get(<span class="string">'http://www.gravatar.com/avatar/'</span>+crypto.createHash(<span class="string">'md5'</span>).update(email).digest(<span class="string">'hex'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">                     <span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                     resp.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">                                chunk.copy(buf, size);</span><br><span class="line">                                size += chunk.length;</span><br><span class="line">                     &#125;)</span><br><span class="line">                     .on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                                res.write(buf.slice(<span class="number">0</span>, size));</span><br><span class="line">                                res.end();</span><br><span class="line">                     &#125;);</span><br><span class="line">           &#125;);</span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></p><p>우리는 이미지를 Gravatar를 통해서 가져오고 이를 buffer에 담아서 읽습니다. 그리고 요청에 대한 응답을 진행합니다. 이 경우에는 이미지의 사이즈가 그다지 크지가 않습니다. 그런데 만약에 사이즈가 수천 메가바이트 정도가 된다고 하면 또 다른 문제입니다. 코드를 수정해 보겠습니다.<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">http.createServer()</span><br><span class="line">.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">var</span> email = req.url.substr(req.url.lastIndexOf(<span class="string">'/'</span>)+<span class="number">1</span>);</span><br><span class="line">           <span class="keyword">if</span>(!email) &#123;</span><br><span class="line">                     res.writeHead(<span class="number">404</span>);</span><br><span class="line"></span><br><span class="line">                     <span class="keyword">return</span> res.end();</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           http.get(<span class="string">'http://www.gravatar.com/avatar/'</span>+crypto.createHash(<span class="string">'md5'</span>).update(email).digest(<span class="string">'hex'</span>), <span class="function"><span class="keyword">function</span>(<span class="params">resp</span>) </span>&#123;</span><br><span class="line">                     resp.pipe(res);</span><br><span class="line">           &#125;);</span><br><span class="line"></span><br><span class="line">&#125;).listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></p><p>우리는 이미지를 가져와 간단한 pipe를 통해서 사용자에게 응답을 해줍니다. 이렇게 구현을 하면 전체데이터를 다 받은 후에 응답을 해줄 필요가 없습니다.</p><h2 id="Mistake-9-Console-log를-디버깅-용으로-사용함"><a href="#Mistake-9-Console-log를-디버깅-용으로-사용함" class="headerlink" title="Mistake #9: Console.log를 디버깅 용으로 사용함"></a>Mistake #9: <code>Console.log</code>를 디버깅 용으로 사용함</h2><p>Node.js에서의 <code>console.log</code>의 경우는 거의 모든 것들을 콘솔창에 프린트 해줍니다. 객체를 넘기면 자바스크립트 객체로 프린트 해줍니다. 그리고 대부분의 것들을 잘 정돈된 형태로 콘솔창에 띄워줍니다. 하지만 정말로 실제 코드에서는 <code>console.log</code>가 사용되지 않도록 해야 합니다.<br>대신에 더 많은 기능을 담고 있는 라이브러리를 사용하세요. 예를들면 <a href="https://www.npmjs.com/package/debug" target="_blank" rel="noopener">debug</a> 같은 것이 좋은 수단이 될것같습니다. 사용법도 매우 간단합니다. 사이트에 방문해서 더많은 정보를 얻으세요.</p><h2 id="Mistake-10-관리용-프로그램-사용하지-않음"><a href="#Mistake-10-관리용-프로그램-사용하지-않음" class="headerlink" title="Mistake #10: 관리용 프로그램 사용하지 않음"></a>Mistake #10: 관리용 프로그램 사용하지 않음</h2><p>여러분의 Node.js 코드가 실제 제품으로 돌고 있던지 여러분의 데스크탑에서 돌고 있던지 반드시 <a href="https://en.wikipedia.org/wiki/Supervisory_program" target="_blank" rel="noopener">Supervisor Programe</a>을 사용하세요. 여러분의 프로그램을 전체적으로 관리하고 관찰할수 있는 매우 유용한 방법입니다.<br>예상치 못한 에러가 발생하면 이것을 해결하려 들지말고 여러분의 프로그램이 망가지도록 그냥 두고 보세요. 몇초 내로 여러분의 Supervisor가 프로그램을 재실행 시킬것입니다.<br>이 Supervisor프로그램은 여러분의 프로그램이 망가지거나 , 파일의 변화가 있다면 언제든 서버를 재시작 시켜 줍니다. 이는 개발자로 하여금 굉장한 이점을 가져다 줍니다.</p><p><a href="https://www.npmjs.com/package/nodemon" target="_blank" rel="noopener">nodemon</a></p><p><a href="https://www.npmjs.com/package/forever" target="_blank" rel="noopener">forever</a></p><p><a href="https://www.npmjs.com/package/pm2" target="_blank" rel="noopener">pm2</a></p><p><a href="https://www.npmjs.com/package/supervisor" target="_blank" rel="noopener">supervisor</a></p><p>여기 몇 가지 Node.js환경에서 사용가능한 Supervisor 프로그램이 있습니다. 각각의 툴은 장단점을 가지고 있습니다. 원하시는 툴을 선택해서 실제로 적용시켜 보시기 바랍니다.</p><h5 id="출처-Yuby’s-Lab"><a href="#출처-Yuby’s-Lab" class="headerlink" title="출처: Yuby’s Lab."></a>출처: <a href="http://yubylab.tistory.com/entry/Nodejs-개발시-주의사항-10가지-Top-10-Common-Mistakes" target="_blank" rel="noopener">Yuby’s Lab.</a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;이글은 Need Node.js Help? Check These Top 10 Common Node.js Developer Mistakes 제목으로 MAHMUD RIDWAN 이란 개발자가 쓴 Node.js로 개발하면서 발생하는 10가지 실수들에 대한
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="node.log" scheme="https://ddok2.github.io/categories/dev/node-log/"/>
    
    
      <category term="nodejs" scheme="https://ddok2.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://ddok2.github.io/2018/01/03/hello-world/"/>
    <id>https://ddok2.github.io/2018/01/03/hello-world/</id>
    <published>2018-01-03T01:00:01.000Z</published>
    <updated>2019-02-08T08:33:38.550Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
      <category term="dev" scheme="https://ddok2.github.io/categories/dev/"/>
    
      <category term="test.log" scheme="https://ddok2.github.io/categories/dev/test-log/"/>
    
    
      <category term="test" scheme="https://ddok2.github.io/tags/test/"/>
    
  </entry>
  
</feed>
