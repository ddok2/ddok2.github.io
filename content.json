{"meta":{"title":"SUNG.LOG","subtitle":"불라불라불라","description":"Sung's Blog using Hexo","author":"SUNG :D","url":"https://ddok2.github.io"},"pages":[{"title":"ABOUT SUNG","date":"2019-02-08T08:33:38.550Z","updated":"2019-02-08T08:33:38.550Z","comments":false,"path":"about/index.html","permalink":"https://ddok2.github.io/about/index.html","excerpt":"","text":"Hello World!"}],"posts":[{"title":"Docker 에서 MongoDB 이용하기","slug":"docker-mongodb","date":"2018-03-08T05:59:24.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/03/08/docker-mongodb/","link":"","permalink":"https://ddok2.github.io/2018/03/08/docker-mongodb/","excerpt":"","text":"Mongo 검색Command 이용해서 검색하거나 Docker Hub 에서 mongo 를 검색합니다. command 검색: docker search mongo 이미지 받기 및 실행docker pull mongo 위 명령어 없이 run 명령어 사용하면 자동으로 다운받고 실행을 합니다. docker run --name mongo -p 27017:27017 -d mongo 위 명령어를 사용하면 mongod가 기동이 됩니다. Docker Container 접속docker exec -it mongo /bin/bash 위 명령어 실행하면 컨테이너 안으로 들어가서 해당 명령어를 실행합니다. 만일 run 하면서 바로 접속하고 싶으면 다음과 같이 해도 됩니다.docker run -it --name mongo -p 27017:27017 -d mongo /bin/bash","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"docker.log","slug":"dev/docker-log","permalink":"https://ddok2.github.io/categories/dev/docker-log/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ddok2.github.io/tags/docker/"},{"name":"mongodb","slug":"mongodb","permalink":"https://ddok2.github.io/tags/mongodb/"}]},{"title":"macOS에 Azure CLI 2.0 설치하기","slug":"install-azure-cli-mac-os","date":"2018-02-20T01:16:43.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/02/20/install-azure-cli-mac-os/","link":"","permalink":"https://ddok2.github.io/2018/02/20/install-azure-cli-mac-os/","excerpt":"","text":"맥을 이용하는 유저는 Azure CLI를 Homebrew 통해서 설치할수 있습니다. 1. 설치하기Homebrew 통해서 설치하는 것이 가장 쉽습니다. Homebrew 통해 업데이트와 삭제도 쉽게 할수 있으니 Homebrew가 없으면 설치하길 바랍니다. brew update &amp;&amp; brew install azure-cli 설치가 되면 az 명령을 이용하여 Azure CLI를 이용할수 있습니다. 1.1 설치시 발생되는 문제Python 패키지를 찾을 수 없음맥에 설치된 Python이 버전이 일치하지 않을 경우나 설치하는 과정에서 다른 문제가 발생할 수 있습니다.그래서 Python 버전을 찾게 다음과 같이 연결하면 됩니다.brew link --overwrite python3 Azure CLI 1.x가 설치됨낮은 버전이 설치된 경우 Homebrew 업데이트 안해서 발생하는 문제입니다. Homebrew를 업데이트한 후 azure-cli를 업그레이드하면 됩니다.brew update &amp;&amp; brew upgrade azure-cli 2. 업데이트azure-cli는 약 2주마다 새 릴리즈를 한다고 합니다. 주기적인 업데이트를 받을 수 있습니다.brew update &amp;&amp; brew upgrade azure-cli 3. 삭제brew uninstall azure-cli","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"azure.log","slug":"dev/azure-log","permalink":"https://ddok2.github.io/categories/dev/azure-log/"}],"tags":[{"name":"azure","slug":"azure","permalink":"https://ddok2.github.io/tags/azure/"}]},{"title":"Node.js HTTPS 서버 구현","slug":"nodejs-https","date":"2018-02-19T01:19:51.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/02/19/nodejs-https/","link":"","permalink":"https://ddok2.github.io/2018/02/19/nodejs-https/","excerpt":"","text":"1. SSL 인증서, LetsencryptSSL 인증서는 보통 유료로 구매를 해야합니다. 그러나 무료 인증서를 주는 곳이 몇몇 있습니다. Let’s Encrypt : 유료기간이 90일. Comodo Free SSL : 코모도에서 출시한 무료 인증서. CloudFlare One-Click SSL : CloudFlare CDN과 함께 사용 가능함. AWS Certificate Manager 유효기간 자동 갱신. 그외 더 있지만 여기서는 Let’s Encrypt를 이용해서 인증서를 받았습니다. 윈도우 서버에서 테스트를 할 예정이라 letsencrypt-win-simple 이용하여 인증서를 받았습니다.letsencrypt-win-simple 의 자세한 내용은 wiki 를 참고하세요. 2. HTTPS 서버 구현Node.js HTTPS Documentation를 참고하세요. 예제는 아래와 같습니다. 방법 1:// curl -k https://localhost:8000/const https = require('https');const fs = require('fs');const options = &#123; key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'), cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')&#125;;https.createServer(options, (req, res) =&gt; &#123; res.writeHead(200); res.end('hello world\\n');&#125;).listen(8000); 방법 2:const https = require('https');const fs = require('fs');const options = &#123; pfx: fs.readFileSync('test/fixtures/test_cert.pfx'), passphrase: 'sample'&#125;;https.createServer(options, (req, res) =&gt; &#123; res.writeHead(200); res.end('hello world\\n');&#125;).listen(8000); 만일 Express를 이용하여 구현한다면 다음과 같이 구현하면 됩니다. with Express:const express = require('express');const https = require('https');const http = require('http');const fs = require('fs');const options = &#123; key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'), cert: fs.readFileSync('test/fixtures/keys/agent2-cert.cert')&#125;;// Create a service (the app object is just a callback).const app = express();// Create an HTTP service.http.createServer(app).listen(80);// Create an HTTPS service identical to the HTTP service.https.createServer(options, app).listen(443);","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"node.log","slug":"dev/node-log","permalink":"https://ddok2.github.io/categories/dev/node-log/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://ddok2.github.io/tags/nodejs/"}]},{"title":"PRPL 패턴","slug":"prpl-pattern","date":"2018-01-29T00:15:30.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/01/29/prpl-pattern/","link":"","permalink":"https://ddok2.github.io/2018/01/29/prpl-pattern/","excerpt":"","text":"PRPL 패턴이란PRPL 은 다음의 약자입니다. Push: 초기 URL 에서 가장 중요한 리소스만 푸시합니다. Render: 초기 경로를 먼저 렌더링 합니다. Pre-cache: 남은 경로를 사전에 미리 캐시합니다. Lazy-load: 요청에 따라 필요 시 남은 경로를 로드하고 다음 루트를 만들어 보여줍니다. PRPL은 PWA(Progressive Web App)의 목표와 표준을 추구하고 아래와 같은 경우에 최적화를 수행합니다. 최소 상호작용 시간(Time-to-Interactive) 최초 사용 시(진입점과 무관) 우리가 사용하는 휴대기기(핸드폰)에서 업데이트가 릴리즈되는 동안 최대한의 캐싱 효율성 개발 및 배포의 단순성 PRPL은 기술이나 기법보단 모바일 웹의 성능을 개선하려는 비전에 가깝습니다. Polymer 팀이 그 틀을 짜고 이름을 정한 후 Google I/O 2016에 공개했습니다. 공개한 Polymer Shop E-커머셜 데모는 PRPL을 사용한 좋은 예시입니다. 이 데모는 실제 휴대기기에서 각 경로의 상호작용을 통해 놀라운 속도가 실현됩니다. 1.75초만에 나타나는 Polymer Shop 데모 대부분의 프로젝트에서 PRPL 을 완전한 형태로 실현하기는 솔직히 말해 너무 이릅니다.그러나 그러한 마음가짐을 갖거나 다양한 관점에서 비전을 추구하는 것은 절대로 너무 이른 것이 아닙니다.오늘날 PRPL 를 구현하기 위해 앱 개발자, 도구 개발자 및 브라우저 공급업체가 따를 수 있는 유용한 단계들이 많이 있습니다. PRPL 을 가능하게 만드는 기술들 HTTP/2 Server-push 지원 Web Server Web Components 지원 플랫폼 Service Woker 지원 Web Browser 참조 PRPL 패턴 : https://developers.google.com/web/fundamentals/performance/prpl-pattern/","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"web.log","slug":"dev/web-log","permalink":"https://ddok2.github.io/categories/dev/web-log/"}],"tags":[{"name":"web","slug":"web","permalink":"https://ddok2.github.io/tags/web/"},{"name":"prpl","slug":"prpl","permalink":"https://ddok2.github.io/tags/prpl/"}]},{"title":"Docker 명령어 정리","slug":"docker-command","date":"2018-01-12T00:27:53.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/01/12/docker-command/","link":"","permalink":"https://ddok2.github.io/2018/01/12/docker-command/","excerpt":"","text":"Docker Hub에서 이미지 검색$ docker search ubuntu Docker Hub에서 이미지 받기$ docker pull ubuntu Docker 이미지 목록 확인$ docker images 이미지로 컨테이너 실행(Run)$ docker run -t -i --name sung-something ubuntu:lastest bin/bash -i : 컨테이너와 상호작용 -t : tty(터미널)을 사용 -d : -i 옵션의 반대. 컨테이너를 백그라운드 실행 -p [외부포트]:[내부포트] : 포트포워딩 설정 ex) -p 80:8080 -&gt; 외부에서 들어온 80포트 요청을 컨테이너의 8080 포트로 포워딩시킨다. 포트를 여러개 열고 싶으면 -p 80:8080 -p 8088:8088 -p 27017:27017 이런식으로 이어서 쓰면 된다. -v : [외부절대경로]:[내부절대경로] : 컨테이너 외부(호스트) 볼륨과 컨테이너 내부 볼륨을 바인딩시킨다. -c : cpu 스케줄링 점유율 (기본값 1024) -m : 메모리 -rm : 컨테이너가 종료되면 삭제 /bin/bash: 리눅스의 경우 컨테이너에서 bash 쉘을 이용 컨테이너 목록 확인$ docker ps -a : 정지된 컨테이너까지 출력 -q : 컨테이너 ID만 출력 실행중인 컨테이너 shell에서 빠져나오기 exit : 쉘을 빠져나오면서 컨테이너를 종료 ctrl + p + q 입력 : 컨테이너를 종료하지 않고 쉘만 빠져나옴 실행중인 컨테이너로 접속하기$ docker attach sung-something 실행중인 컨테이너 정지하기$ docker stop sung-something 컨테이너 삭제하기$ docker rm sung-something -f : 실행중인 컨테이너도 강제로 정지하고 삭제 컨테이너 모두 삭제하기## Linux$ docker rm $(docker ps -a -q)## Windows&gt; FOR /f &quot;tokens=*&quot; %i IN (&apos;docker ps -a -q&apos;) DO docker rm %i 이미지 삭제하기$ docker rmi ubuntu:latest [이미지 이름]:[태그] 형식을 사용해도 되고 이미지 ID를 사용해도 된다. 이미지 이름만 입력할 경우 태그에 관계없이 이미지 이름만 같으면 모두 삭제된다. 이미지 모두 삭제하기## Linux$ docker rmi $(docker images -q)## Windows&gt; FOR /f &quot;tokens=*&quot; %i IN (&apos;docker images -q -f &quot;dangling=true&quot;&apos;) DO docker rmi %i 컨테이너 변경사항 확인하기$ docker diff [컨테이너 ID or NAME] 어떤 이미지로 실행된 컨테이너 안의 내용의 변경되었다면, 버전 관리 시스템처럼 diff 명령어로 어떤 점이 바뀌었는지 확인할 수 있다. 컨테이너로 이미지 만들기$ docker commit [컨테이너 ID or NAME] [새로운 컨테이너 이름]:[태그] 버전 관리 시스템처럼 commit 명령어로 변경된 컨테이너를 새로운 이미지로 만들 수 있다. Dockerfile을 통한 이미지 빌드$ docker build -t [image name:tag] -f [Dockerfile 경로] 이미지 파일 Export$ sudo docker save -o [내보낼 경로]/[내보낼 이름] [내보낼 이미지 ID or NAME] 이미지 파일 Import$ sudo docker load -i [이미지 파일 경로] 볼륨 관련 명령어## 볼륨 만들기$ docker volume create [VOLUME NAME]## 볼륨 목록 보기$ docker volume ls## 특정 볼륨 상세정보 보기$ docker volume inspect [VOLUME ID or NAME]## 볼륨 삭제하기$ docker volume rm [VOLUME ID or NAME]## 사용하지 않는 볼륨 모두 삭제$ docker volume prune","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"docker.log","slug":"dev/docker-log","permalink":"https://ddok2.github.io/categories/dev/docker-log/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://ddok2.github.io/tags/docker/"}]},{"title":"NVM으로 노드 버전 관리하기","slug":"nvm-version-control","date":"2018-01-05T02:30:06.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/01/05/nvm-version-control/","link":"","permalink":"https://ddok2.github.io/2018/01/05/nvm-version-control/","excerpt":"","text":"NVM은 로컬에 다양한 버전의 노드를 설치할 수 있게 해주는 툴이다. 설치NVM 문서에 있는 설치 스크립트로 설치한다. cURL:$ curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash or Wget:$ wget -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash 설치하고 나면 profile(~/.bash_profile, ~/.zshrc, ~/.profile, ~/.bashrc) 에 아래를 등록한다. ~/.bash_profile:export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot; # This loads nvm Mac 같은 경우 brew로 설치한 경우:export NVM_DIR=&quot;$HOME/.nvm&quot;. &quot;/usr/local/opt/nvm/nvm.sh&quot; # This loads nvm 그리고 ~/.nvm 폴더를 생성한다.(만일 없으면 말이다.) 마지막으로:$ source ~/.bash_profile 잘 설치되었는지 확인:$ command -v nvm 명령어NVM 에서 지원하는 노드 버전 확인:$ nvm ls-remote 로컬에 설치된 노드 확인:$ nvm ls v4.8.7 v6.12.2-&gt; v8.9.3 systemdefault -&gt; v8.9.3node -&gt; stable (-&gt; v8.9.3) (default)stable -&gt; 8.9 (-&gt; v8.9.3) (default)iojs -&gt; N/A (default)lts/* -&gt; lts/carbon (-&gt; v8.9.3)lts/argon -&gt; v4.8.7lts/boron -&gt; v6.12.2lts/carbon -&gt; v8.9.3 해당 버전으로 변경:$ nvm use v6.12.2 해당 버전을 기본으로 변경:$ nvm alias default systemdefault -&gt; system WebStorm 에서 이용하기링크 생성:$ cd ~/.nvm/versions/node$ ln -s v6.12.2 default$ ls -ld defaultdefault@ -&gt; v6.12.2 WebStorm 노드 경로 설정:~/.nvm/version/node/default/bin/node node_modules 경로:~/.nvm/version/node/default/lib/node_modules 새로운 노드 버전 설치 후:$ nvm install v6.12.3$ cd ~/.nvm/versions/node$ rm default$ ln -s v6.12.3 default 해당 자료는 https://github.com/ddok2/TIL/blob/master/nodejs/nvm-version-control.md 에 작성된 자료이다.","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"node.log","slug":"dev/node-log","permalink":"https://ddok2.github.io/categories/dev/node-log/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://ddok2.github.io/tags/nodejs/"},{"name":"nvm","slug":"nvm","permalink":"https://ddok2.github.io/tags/nvm/"}]},{"title":"Node.js Security Overview","slug":"nodejs-security-overview","date":"2018-01-04T00:17:07.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/01/04/nodejs-security-overview/","link":"","permalink":"https://ddok2.github.io/2018/01/04/nodejs-security-overview/","excerpt":"","text":"해당 자료는 https://github.com/ddok2/TIL/blob/master/nodejs/nodejs-security-overview.md에 작성된 자료이다. Security in the NPM ecosystem Moving the whole traffic of the registry to HTTPS Protect your npm account with two-factor authentication and read-only tokens Using Two-Factor Authentication Securing your Node.js applicationsUsing the Helmet moduleHelmet을 이용하면 웹 취약성으로부터 앱을 보호할 수 있다. csp는 Content-Security-Policy 헤더를 설정하여 XSS(Cross-site scripting) 공격 및 기타 교차 사이트 인젝션을 예방한다. hidePoweredBy는 X-Powered-By 헤더를 제거한다. hpkp는 Public Key Pinning 헤더를 추가하여, 위조된 인증서를 이용한 중간자 공격을 방지한다. hsts는 서버에 대한 안전한(SSL/TLS를 통한 HTTP) 연결을 적용하는 Strict-Transport-Security 헤더를 설정한다. ieNoOpen은 IE8 이상에 대해 X-Download-Options를 설정한다. noCache는 Cache-Control 및 Pragma 헤더를 설정하여 클라이언트 측에서 캐싱을 사용하지 않도록 한다. noSniff는 X-Content-Type-Options 를 설정하여, 선언된 콘텐츠 유형으로부터 벗어난 응답에 대한 브라우저의 MIME 가로채기를 방지한다. frameguard는 X-Frame-Options 헤더를 설정하여 clickjacking에 대한 보호를 제공한다. xssFilter는 X-XSS-Protection을 설정하여 대부분의 최신 웹 브라우저에서 XSS(Cross-site scripting) 필터를 사용하도록 한다. $ npm i helmet -S 이후 코드에서 Helmet을 사용하는 방법은 다음과 같다.const express = require('express');const helmet = require('helmet');const app = express();app.use(helmet()); X-Powered-By헤더를 사용하지 않기app.disabled('x-powered-by'); 물론 Helmet를 이용하면 자동으로 위의 작업을 한다. Validating user input command injection SQL injection stored cross-site scripting 위 항목을 피하기 위해서 사용자 입력을 유효성검사를 해야한다.사용자 유효성 검사하기에 좋은 라이브러리는 Joi이다. 사용방법은 다음과 같다.const Joi = require('joi'); const schema = Joi.object().keys(&#123; username: Joi.string().alphanum().min(3).max(30).required(), password: Joi.string().regex(/^[a-zA-Z0-9]&#123;3,30&#125;$/), access_token: [Joi.string(), Joi.number()], birthyear: Joi.number().integer().min(1900).max(2013), email: Joi.string().email()&#125;).with('username', 'birthyear').without('password', 'access_token'); // Return result.const result = Joi.validate(&#123; username: 'abc', birthyear: 1994 &#125;, schema);// result.error === null -&gt; valid // You can also pass a callback which will be called synchronously with the validation result.Joi.validate(&#123; username: 'abc', birthyear: 1994 &#125;, schema, function (err, value) &#123; &#125;); // err === null -&gt; valid Secure Coding StyleDo not use eval()Eval은 애플리케이션에 코드 인젝션 공격을 가능하게 한다. 이를 사용하려고 하지마라. eval() 뿐만 아니라 아래의 표현도 피해야한다. 아래의 표현은 백그라운드로 eval() 를 사용한다. setInterval(String, 2) setTimeout(String, 2) new Function(String) Always use use strict;use strict; 를 사용하면 자바스크립트의 “변종”을 허용하지 않게 한다. 또한 몇몇 암묵적인 에러들을 제거해주고 에러로그를 throw한다.'use strict';const sung = &#123;a: 1, b: 2&#125;; Set cookie scope쿠키로 인해 앱이 악용에 노출되지 않도록 하기 위해 기본 세션 쿠키 이름을 사용하지 말고 쿠키 보안 옵션을 적절히 설정한다. 기본 세션 쿠키 이름을 사용하지 않음기본 세션 쿠키 이름을 사용하면 앱을 공격에 노출시킬 수 있다. 이로 인해 제기되는 보안 문제는 X-Powered-By와 유사하며, 잠재적인 공격자는 이를 이용해 서버의 지문을 채취한 후 이에 따라 공격 대상을 설정할 수 있다. const session = require('express-session');app.set('trust proxy', 1); // trust first proxyapp.use(session(&#123; secret: 's3Cur3', name: 'sessionId'&#125;)); 쿠키 보안 옵션 설정다음과 같은 쿠키 옵션을 설정하여 보안을 강화할 필요가 있다. secure - 브라우저가 HTTPS를 통해서만 쿠키를 전송하도록 한다. httpOnly - 쿠키가 클라이언트 JavaScript가 아닌 HTTP(S)를 통해서만 전송되도록 하며, 이를 통해 XSS(Cross-site scripting) 공격으로부터 보호할 수 있다. domain - 쿠키의 도메인을 표시하고 URL이 요청되고 있는 서버의 도메인에 대해 비교할 때 사용한다. 두 도메인이 일치하는 경우에는 그 다음으로 경로 속성을 확인해라. path - 쿠키의 경로를 표시한다. 요청 경로에 대해 비교할 때 사용하며 이 경로와 도메인이 일치하는 경우에는 요청되고 있는 쿠키를 전송한다. expires - 지속적 쿠키에 대한 만기 날짜를 설정하는 데 사용된다. const session = require('cookie-session');const express = require('express');const app = express();const expiryDate = new Date( Date.now() + 60 * 60 * 1000 ); // 1 hourapp.use(session(&#123; name: 'session', keys: ['key1', 'key2'], cookie: &#123; secure: true, httpOnly: true, domain: 'example.com', path: 'foo/bar', expires: expiryDate &#125; &#125;)); Audit your modules with the Node Security Platformnsp는 Node Security Platform의 주요 커맨드라인 인터페이스이다.nsp는 취약한 모듈들을 점검하기 위해 package.json 파일 혹은 npm-shirnkwrap.json 파일을 NSP API를 통해 감시한다. $ npm i nsp -g# From inside your project directory$ nsp check 유효성 검증을 위한 npm-shrinkwrap.json 파일을 nodesecurity.io에 제출하려면 다음과 같은 명령을 사용한다.$ nsp audit-shrinkwrap 유효성 검증을 위한 package.json 파일을 nodesecurity.io에 제출하려면 다음과 같은 명령을 사용한다.$ nsp audit-package Look for vulnerabilities with Retire.jsRetire.js는 사용하고 있는 모듈 버전들에 대해 알려진 취약점을 탐지해주기 위한 모듈이다. $ npm i retire -g retire 명령으로 실행하면 node_modules 디렉토리내의 모듈들의 취약점을 찾을 수 있다. (또한 참고로 retire.js는 node_modules 외에 프론트엔드 라이브러리에서도 잘 작동한다.) 출처 Node.js Security Overview (17.10.12) Production Best Practices: Security Node.js Security Tutorial","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"node.log","slug":"dev/node-log","permalink":"https://ddok2.github.io/categories/dev/node-log/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://ddok2.github.io/tags/nodejs/"},{"name":"security","slug":"security","permalink":"https://ddok2.github.io/tags/security/"}]},{"title":"Node.js 개발시 주의사항 10가지 (3년전 이야기)","slug":"top10-common-mistakes","date":"2018-01-03T01:21:49.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/01/03/top10-common-mistakes/","link":"","permalink":"https://ddok2.github.io/2018/01/03/top10-common-mistakes/","excerpt":"","text":"이글은 Need Node.js Help? Check These Top 10 Common Node.js Developer Mistakes 제목으로 MAHMUD RIDWAN 이란 개발자가 쓴 Node.js로 개발하면서 발생하는 10가지 실수들에 대한 내용입니다. 원문에서 확인 하시면 됩니다. Mistake #1: 이벤트 루프의 블록킹Node.js의 자바스크립트의 경우(브라우저와 마찬가지로) 싱글 쓰레드 방식의 환경입니다. 이 말은 우리가 어플리케이션을 만들면 두 개의 작업을 병렬로 진행하는 것이 불가능하다는 말입니다. 대신에 IO기반으로 비동기적으로 동시에 발생하는 여러 작업들을 다루고 있습니다.예를들면 Node.js가 데이터베이스의 데이터를 가져오는 작업을 요청을 한다면 데이터를 가져오는 동안 어플리케이션의 다른 일에 집중 할 수 있다는 말입니다.db.User.get(userId, function(err, user) &#123; // 여기에 실제로 데이터가 불러와 지는 동안은 다른 일을 합니다.&#125;) 그런데 만약에 CPU 기반의 코드를 작성한다고 가정을 해보겠습니다. 예를 들어 엄청나게 큰 배열을 sorting 하는 작업이나 엄청나게 큰 loop를 도는 작업을 하는 작업들이 있을 수 있습니다.function sortUsersByAge(users) &#123; users.sort(function(a, b) &#123; return a.age &lt; b.age ? -1 : 1; &#125;);&#125; 이런 형태의 코드가 실제로 문제가 될 수 있습니다. 이 경우에는 적은 수의 사용자라면 별로 문제가 되지 않을 테지만 수천 수만 명이 동시에 접속해서 동일한 작업을 요청하게 된다면 다른 작업이 마칠 때까지 다른 사용자들은 결과를 기다릴 수 밖에 없는 문제가 발생합니다. 결국 callback을 통한 비 동기적인 코드의 효과가 전혀 없어지게 됩니다. 위와 같은 문제를 해결하는 가장 이상적인 해결책은 이미 sorting이 된 결과를 DB상에서 처리해서 내려주는 것입니다. 실제로 Nodejs에서는 이 문제를 해결할만한 명확한 해결책은 없습니다. DB에서 최대한 처리된 데이터를 내려다 준다 던지 하는 각 상황에 맞춰 해결하는 수밖에 없습니다. 우리는 오직 하나 그저 CPU에 지나치게 의존하는 작업들을 피하라는 것입니다. Mistake #2: 한번 이상의 Callback 함수의 실행자바스크립트는 callback에 의존하고 있습니다. 브라우저상에서 이벤트를 처리하기 위해서 참조된 함수를 넘기거나 또는 익명의 함수를 선언하여 callback을 구현하고 있습니다. Node.js 에서는 callback이 비동기적인 코드가 각각 통신하는 유일한 방법입니다. ES6의 promise 기법이 소개 되기 전까지는 말이지요. promise 기법에 대한 정보는 이곳 에서 얻으실 수 있습니다. callback은 여전히 많은 수의 개발자들이 API를 설계할 때 callback을 기반으로 설계를 하고 있습니다. 여기서 문제는 바로 이 callback함수가 의도치 않게 한번 이상 호출이 되는 경우가 있다는 것입니다. 일반적으로 함수의 제일 마지막 매개변수에 비동기적으로 무언가를 하게 하기 위한 무언가를 전달하고 그 무언가는 해당 함수의 요청이 완료가 되면 실행이 되는 방식입니다. 일반적인 callback의 방식입니다. 아래의 코드를 보기겠습니다.module.exports.verifyPassword = function(user, password, done) &#123; if(typeof password !== 'string') &#123; done(new Error('password should be a string')); return; &#125; computeHash(password, user.passwordHashOpts, function(err, hash) &#123; if(err) &#123; done(err); &#125; done(null, hash === user.passwordHash); &#125;);&#125; return 문이 마지막에는 매번 done을 호출하는지 보시기 바랍니다. 이는 현재의 함수의 실행의 마지막 부분에 자동으로 callback 함수를 실행하지 않기 때문에 반드시 callback()를 호출을 해줘야 합니다. 즉 해당 함수가 끝이 났다는 말입니다. 그런데 위의 코드의 경우에 password로 string이 아닌 값을 넘기게 된다면 “password should be a string” 라는 문구를 리턴하게 될 것입니다. 그리고 코드가 끝이 나야 합니다. 하지만 위의 함수는 computeHash라는 함수로 진입을 하게 됩니다. 즉, 함수가 끝이 났음을 인지하지 못하고 있습니다. 결국 callback()가 두 번이나 호출이 되어 우리가 원하는 형태의 함수 로직을 구현할 수 가 없게 되었습니다. 위와 같은 Nodejs의 에러를 피하기 위해서 개발자들은 반드시 callback() 앞에 return을 붙이는 습관이 필요합니다.if(err) &#123; return done(err);&#125; 이런 형태로 말입니다. 많은 비동기적인 함수들의 return 값들은 대부분 의미를 가지지 않습니다. 반드시 return에 콜백함수를 넘겨 그래서 이러한 습관은 위에서 발생한 문제를 피하는 가장 쉬운 방법입니다. Mistake #3: 꼬리에 꼬리를 무는 Callback 함수callback – hell 이라고 불리는 꼬리에 꼬리를 무든 callback 함수의 연결입니다. 이는 Nodejs 그 자체의 문제는 아니지만 자칫하다가는 코드의 흐름이 엉망이 되는 원인이 됩니다.function handleLogin(..., done) &#123; db.User.get(..., function(..., user) &#123; if(!user) &#123; return done(null, 'failed to log in'); &#125; utils.verifyPassword(..., function(..., okay) &#123; if(okay) &#123; return done(null, 'failed to log in'); &#125; session.login(..., function() &#123; done(null, 'logged in'); &#125;); &#125;); &#125;);&#125; 이런 코드는 유지보수는 물론 코드의 가독성 마저 낮춰버리는 경향이 있습니다. 이 문제를 해결하는 방법은 꽤나 간단합니다. 기능별로 함수를 정의 하여 함수끼리 연결을 시키는 것입니다. 하지만 무엇보다 가장 깔끔한 해결책 중에 하나는 Nodejs 패키지중에 자바스크립트의 비동기 패턴을 다뤄주는 유틸리리티인 Async.js 를 사용하는 것입니다.function handleLogin(done) &#123; async.waterfall([ function(done) &#123; db.User.get(..., done); &#125;, function(user, done) &#123; if(!user) &#123; return done(null, 'failed to log in'); &#125; utils.verifyPassword(..., function(..., okay) &#123; done(null, user, okay); &#125;); &#125;, function(user, okay, done) &#123; if(okay) &#123; return done(null, 'failed to log in'); &#125; session.login(..., function() &#123; done(null, 'logged in'); &#125;); &#125; ], function() &#123; // ... &#125;)&#125; 위의 코드는 하나의 예일뿐 다양한 패턴에 맞춰 다양한 메서드를 지원하니 사이트에 방문하셔서 더 많은 정보를 얻으시기 바랍니다. Mistake #4: Callback 함수가 동기적으로 동작하길 기대함callback을 통한 비동기적인 프로그래밍은 자바스크립트와 Nodejs의 꽤나 특별한 방식입니다. 다른 프로그래밍 언어에서는 실행의 순서를 예측하는데 익숙합니다. 두개의 실행문이 있으면 하나가 실행이 되면 다른 하나가 다음에 실행이 되는 방식으로 별다른 지시가 없다면 문장을 건너뛰고 하는 일은 없을 것입니다. 만약 이런 뛰어 넘는 일이 발생하더라도 조건문, 반복문, 함수의 호출등 으로 제한이 있습니다. 하지만 자바스크립트에서는 콜백의 특정 기능이 해당 함수가 끝이 날 때까지 실행되지 않는 경우도 있을 수 있습니다. 현재 함수의 실행의 중단 없이 그냥 끝까지 실행이 됩니다. 예를 들면 아래와 같은 코드입니다.function testTimeout() &#123; console.log(“Begin”); setTimeout(function() &#123; console.log(“Done!”); &#125;, duration * 1000); console.log(“Waiting..”);&#125; testTimeout이라는 함수가 실행이되면 우선 Begin이라는 글이 찍히고 다음으로는 Waiting.. 그리고 1초가 지난 후에애 Done! 이라는 글자가 찍히게 됩니다. 콜백이 실행되고 다음에 발생해야하는 무언가는 반드시 콜백함수 안에서 다뤄야만 합니다. Mistake #5: module.exports 대신에 exports를 선언함.Node.js의 경우에는 각각의 파일을 고립된 작은 모듈로 취급을 합니다. 만약에 여러분의 패키지가 a.js와 b.js 라는 두개의 파일로 구성이 되어있다고 하겠습니다. 이때 b.js가 기능적으로 a.js에 접근을 해야하는 경우 a.js는 반드시 export 객체의 프로퍼티로 추가되어 있어야 합니다. // a.jsexports.verifyPassword = function(user, password, done) &#123; ... &#125; 이 코드를 통해서 누구든지 a.js를 require 만 시켜주면 객체의 프로퍼티 함수로 verifyPassword 를 사용하는 것이 가능합니다. // b.jsrequire('a.js') // &#123; verifyPassword: function(user, password, done) &#123; ... &#125; &#125; 하지만 만약에 verifyPassword 함수를 어떠한 객체의 프로퍼티가 아닌 직접적으로 export시키고 싶은 경우는 어떻게 해야 할까요?// a.jsmodule.exports = function(user, password, done) &#123; ... &#125; exports를 모듈 객체의 프로퍼티로 다루고 있습니다. 여기서 우리는 exports와 module.exports를 구분하는 것이 매우 중요합니다. 간략히 요약을 하면 module.export를 사용하면 export객체에 선언된 모든 정보들은 무시하고 가장 우선적으로 정보가 선택이됩니다. Mistake #6: 함수의 에러를 Callback 함수 내부로 던져버림자바스크립트는 예외처리의 개념이 존재합니다. 이는 거의 전통적인 언어 ,예를 들면 Java, C++ 같은 언어처럼 예외를 다루는 기능을 제공합니다. 자바스크립트는 try-catch 블록을 통해 에러를 throw하고 catch하는 것이 가능합니다.function slugifyUsername(username) &#123; if(typeof username === 'string') &#123; throw new TypeError('expected a string username, got '+(typeof username)); &#125; // ...&#125;try &#123; var usernameSlug = slugifyUsername(username);&#125; catch(e) &#123; console.error('Oh no!');&#125; 하지만 try-catch의 경우에는 비동기적인 상황에서는 여러분이 기대하는 대로 동작을 하지않을것입니다. 예를들어 비동기적인 기능을 가진 엄청나게 긴 코드를 하나의 큰 try-catch 구문에 묶어서 코드를 안정적으로 구현하고자 하지만 실제로는 기대한 대로 동작하지 않습니다.try &#123; db.User.get(userId, function(err, user) &#123; if(err) &#123; throw err &#125; // ... usernameSlug = slugifyUsername(user.username); // ... &#125;);&#125; catch(e) &#123; console.log('Oh no!');&#125; db.User.get 의 콜백이 비동기적으로 실행이 되면, 해당 콜백 함수의 스코프안의 try-catch문에서 에러를 처리하게 될 것입니다. 즉 에러가 발생했지만 그 에러를 콜백함수 내에서 처리한다는 말입니다. 즉, 에러를 처리하러 catch문으로 들어갈 일이 없다는 말입니다.이게 Node.js가 에러를 다루는 조금은 다른 방식입니다. 그래서 반드시 콜백함수는 (err, …) 과 같은 패턴으로 인자를 다룹니다. 첫 번째 인자는 반드시 에러가 발생하면 에러를 다루는 인자가 전달되어야 합니다. Mistake #7: 모든 숫자가 정수형이라는 착각자바스크립트에서의 숫자는 소수점을 가진 숫자입니다. 실제도 정수형 데이터 타입은 존재하지 않습니다. 여러분은 이게 어떤 문제가 되는 것을 원치 않을 것입니다.우리가 보는 숫자는 실제로 정수부분만을 우리가 보는 것이고 뒤에는 우리가 보지 못하는 소수부분을 감추고 있습니다. 그러다 보니 숫자를 계산하다 보면 우리가 원치 않은 결과를 만들어 내는 경우가 있습니다.Math.pow(2, 53)+1 === Math.pow(2, 53) 실제 논리적으로는 말이 안되지만 Node.js(자바스크립트) 상에서는 true 로 리턴이 됩니다. 못 믿으시겠다면 당장 브라우저의 콘솔창을 띄우시고 확인해보시기 바랍니다.이런 자바스크립트가 숫자를 다루는 부분에 있어서의 문제는 여기서 끝이 아닙니다. 심지어 부동소숫점을 가진 숫자라도 정수를 다루던 연산자가 동일하게 동작을 합니다.5 % 2 === 1 // true5 &gt;&gt; 1 === 2 // true 하지만 산수를 하던 연산자와는 달리 비트단위를 다루는 연산자나 시프트를 다루는 연산자의 경우에는 매우 큰 정수에 대해서 오직 마지막의 32bit까지만 인지하고 동작을 합니다. 예를들면Math.pow(2, 53) 를 1만큼 시프트시키는 연산을 진행하면 결과는 항상 0입니다. 그리고 or 로 비트단위 연산자를 시행하면 항상 1을 결과값으로 내놓습니다. Math.pow(2, 53) / 2 === Math.pow(2, 52) // trueMath.pow(2, 53) &gt;&gt; 1 === 0 // trueMath.pow(2, 53) | 1 === 1 // true 즉, 큰 정수를 다룰 때는 우리가 생각하는 정수가 아닌 수가 된다는 말입니다. 실제로 이렇게 큰 수들을 다룰 일은 거의 없지만 그래도 큰 수를 다루게 된다면 많은 수의 라이브러리들이 큰수를 문제없이 동작하게 만들어 주고 있습니다. 예를들면 bignum 같은 라이브러리들이 있습니다. Mistake #8: Streaming APIs의 장점을 무시함우선 작은 프록시 서버를 만들기로 하죠. 서버는 간단하게 요청이 오면 다른 웹 서버의 컨텐츠를 가져오는 역할을 할 것입니다. 예제는 Gravatar 서버로부터 아바타 이미지를 가져오는 작업을 합니다.var http = require('http');var crypto = require('crypto');http.createServer().on('request', function(req, res) &#123; var email = req.url.substr(req.url.lastIndexOf('/')+1); if(!email) &#123; res.writeHead(404); return res.end(); &#125; var buf = new Buffer(1024*1024); http.get('http://www.gravatar.com/avatar/'+crypto.createHash('md5').update(email).digest('hex'), function(resp) &#123; var size = 0; resp.on('data', function(chunk) &#123; chunk.copy(buf, size); size += chunk.length; &#125;) .on('end', function() &#123; res.write(buf.slice(0, size)); res.end(); &#125;); &#125;);&#125;).listen(8080); 우리는 이미지를 Gravatar를 통해서 가져오고 이를 buffer에 담아서 읽습니다. 그리고 요청에 대한 응답을 진행합니다. 이 경우에는 이미지의 사이즈가 그다지 크지가 않습니다. 그런데 만약에 사이즈가 수천 메가바이트 정도가 된다고 하면 또 다른 문제입니다. 코드를 수정해 보겠습니다.http.createServer().on('request', function(req, res) &#123; var email = req.url.substr(req.url.lastIndexOf('/')+1); if(!email) &#123; res.writeHead(404); return res.end(); &#125; http.get('http://www.gravatar.com/avatar/'+crypto.createHash('md5').update(email).digest('hex'), function(resp) &#123; resp.pipe(res); &#125;);&#125;).listen(8080); 우리는 이미지를 가져와 간단한 pipe를 통해서 사용자에게 응답을 해줍니다. 이렇게 구현을 하면 전체데이터를 다 받은 후에 응답을 해줄 필요가 없습니다. Mistake #9: Console.log를 디버깅 용으로 사용함Node.js에서의 console.log의 경우는 거의 모든 것들을 콘솔창에 프린트 해줍니다. 객체를 넘기면 자바스크립트 객체로 프린트 해줍니다. 그리고 대부분의 것들을 잘 정돈된 형태로 콘솔창에 띄워줍니다. 하지만 정말로 실제 코드에서는 console.log가 사용되지 않도록 해야 합니다.대신에 더 많은 기능을 담고 있는 라이브러리를 사용하세요. 예를들면 debug 같은 것이 좋은 수단이 될것같습니다. 사용법도 매우 간단합니다. 사이트에 방문해서 더많은 정보를 얻으세요. Mistake #10: 관리용 프로그램 사용하지 않음여러분의 Node.js 코드가 실제 제품으로 돌고 있던지 여러분의 데스크탑에서 돌고 있던지 반드시 Supervisor Programe을 사용하세요. 여러분의 프로그램을 전체적으로 관리하고 관찰할수 있는 매우 유용한 방법입니다.예상치 못한 에러가 발생하면 이것을 해결하려 들지말고 여러분의 프로그램이 망가지도록 그냥 두고 보세요. 몇초 내로 여러분의 Supervisor가 프로그램을 재실행 시킬것입니다.이 Supervisor프로그램은 여러분의 프로그램이 망가지거나 , 파일의 변화가 있다면 언제든 서버를 재시작 시켜 줍니다. 이는 개발자로 하여금 굉장한 이점을 가져다 줍니다. nodemon forever pm2 supervisor 여기 몇 가지 Node.js환경에서 사용가능한 Supervisor 프로그램이 있습니다. 각각의 툴은 장단점을 가지고 있습니다. 원하시는 툴을 선택해서 실제로 적용시켜 보시기 바랍니다. 출처: Yuby’s Lab.","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"node.log","slug":"dev/node-log","permalink":"https://ddok2.github.io/categories/dev/node-log/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://ddok2.github.io/tags/nodejs/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-01-03T01:00:01.000Z","updated":"2019-02-08T08:33:38.550Z","comments":true,"path":"2018/01/03/hello-world/","link":"","permalink":"https://ddok2.github.io/2018/01/03/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"dev","slug":"dev","permalink":"https://ddok2.github.io/categories/dev/"},{"name":"test.log","slug":"dev/test-log","permalink":"https://ddok2.github.io/categories/dev/test-log/"}],"tags":[{"name":"test","slug":"test","permalink":"https://ddok2.github.io/tags/test/"}]}]}